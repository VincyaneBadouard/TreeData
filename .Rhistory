if(ValuesColName == "3") ValuesColName <- "TreeHeight"
# Work only with 1 col to create from the wide format columns
Data <- data.table::melt(Data,
measure.vars = ColToTranspos, # cols to rows (arguments pour lesquels un vecteur est renseigné)
variable.name = ColToTranspos_argname, # name of the new column (length=1) that contains the names of the transposed variables
value.name = ValuesColName) # name of the new column that contains the values of the transposed variables
if(ColToTranspos_argname == "Time"){
Time <- ColToTranspos_argname
}else{
stop(cat("To create the cases where 'Time' is not the variable to transpose"))
}
} # ColToTranspos_argname == 1
View(Data)
CharacVar <- c(Plot, SubPlot, TreeFieldNum, IdTree, ScientificName, VernName, Family, Genus, Species) # character variables
CharacVar <- CharacVar[!CharacVar %in% "none"]
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c(Time, Size, PlotArea, X, Y, TreeHeight) # numeric variables
NumVar <- NumVar[!NumVar %in% "none"]
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
View(Data)
Data = ParacouSubsetWide
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
ArgsNames <- c("Plot", "SubPlot", "Time", "TreeFieldNum", "IdTree", # arguments names
"LifeStatus", "Size", "POM", "X", "Y", "ScientificName",
"VernName", "Family", "Genus", "Species", "CommercialSp", "TreeHeight")
ColToTranspos_argname <- vector("character") # empty vectors
for (N in 1:length(ArgsNames)) {
if(length(unlist(ColsList[ ArgsNames[[N]] ])) > 1) # arg = multiple values
ColToTranspos_argname <- c(ColToTranspos_argname, ArgsNames[[N]] )
}
# User col names in character (=argument values)
ColToTranspos <- unlist(ColsList[ColToTranspos_argname], use.names = FALSE)
ColToTranspos <- ColToTranspos[!ColToTranspos %in% "none"]
if(length(ColToTranspos_argname) == 1){
ValuesColName <- readline(cat("To which variable do the values in columns '", ColToTranspos,"' correspond?
1: Size\n
2: POM\n
3: TreeHeight\n")) # question to the user
if(ValuesColName == "1") ValuesColName <- "Size"
if(ValuesColName == "2") ValuesColName <- "POM"
if(ValuesColName == "3") ValuesColName <- "TreeHeight"
# Work only with 1 col to create from the wide format columns
Data <- data.table::melt(Data,
measure.vars = ColToTranspos, # cols to rows (arguments pour lesquels un vecteur est renseigné)
variable.name = ColToTranspos_argname, # name of the new column (length=1) that contains the names of the transposed variables
value.name = ValuesColName) # name of the new column that contains the values of the transposed variables
if(ColToTranspos_argname == "Time"){
Time <- ColToTranspos_argname
}else{
stop(cat("To create the cases where 'Time' is not the variable to transpose"))
}
} # ColToTranspos_argname == 1
### as.numeric
NumVar <- c(Time, Size, PlotArea, X, Y, TreeHeight) # numeric variables
NumVar <- NumVar[!NumVar %in% "none"]
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
View(Data)
Data = ParacouSubsetWide
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
ArgsNames <- c("Plot", "SubPlot", "Time", "TreeFieldNum", "IdTree", # arguments names
"LifeStatus", "Size", "POM", "X", "Y", "ScientificName",
"VernName", "Family", "Genus", "Species", "CommercialSp", "TreeHeight")
ColToTranspos_argname <- vector("character") # empty vectors
for (N in 1:length(ArgsNames)) {
if(length(unlist(ColsList[ ArgsNames[[N]] ])) > 1) # arg = multiple values
ColToTranspos_argname <- c(ColToTranspos_argname, ArgsNames[[N]] )
}
# User col names in character (=argument values)
ColToTranspos <- unlist(ColsList[ColToTranspos_argname], use.names = FALSE)
ColToTranspos <- ColToTranspos[!ColToTranspos %in% "none"]
if(length(ColToTranspos_argname) == 1){
ValuesColName <- readline(cat("To which variable do the values in columns '", ColToTranspos,"' correspond?
1: Size\n
2: POM\n
3: TreeHeight\n")) # question to the user
if(ValuesColName == "1") ValuesColName <- "Size"
if(ValuesColName == "2") ValuesColName <- "POM"
if(ValuesColName == "3") ValuesColName <- "TreeHeight"
# Work only with 1 col to create from the wide format columns
Data <- data.table::melt(Data,
measure.vars = ColToTranspos, # cols to rows (arguments pour lesquels un vecteur est renseigné)
variable.name = ColToTranspos_argname, # name of the new column (length=1) that contains the names of the transposed variables
value.name = ValuesColName) # name of the new column that contains the values of the transposed variables
if(ColToTranspos_argname == "Time"){
Time <- ColToTranspos_argname
}else{
stop(cat("To create the cases where 'Time' is not the variable to transpose"))
}
} # ColToTranspos_argname == 1
View(Data)
ColToTranspos
ColToTranspos_argname
ValuesColName
Time = c("2016","2017","2018","2019","2020")
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
ArgsNames <- c("Plot", "SubPlot", "Time", "TreeFieldNum", "IdTree", # arguments names
"LifeStatus", "Size", "POM", "X", "Y", "ScientificName",
"VernName", "Family", "Genus", "Species", "CommercialSp", "TreeHeight")
ColToTranspos_argname <- vector("character") # empty vectors
for (N in 1:length(ArgsNames)) {
if(length(unlist(ColsList[ ArgsNames[[N]] ])) > 1) # arg = multiple values
ColToTranspos_argname <- c(ColToTranspos_argname, ArgsNames[[N]] )
}
# User col names in character (=argument values)
ColToTranspos <- unlist(ColsList[ColToTranspos_argname], use.names = FALSE)
ColToTranspos <- ColToTranspos[!ColToTranspos %in% "none"]
if(length(ColToTranspos_argname) == 1){
ValuesColName <- readline(cat("To which variable do the values in columns '", ColToTranspos,"' correspond?
1: Size\n
2: POM\n
3: TreeHeight\n")) # question to the user
if(ValuesColName == "1") ValuesColName <- "Size"
if(ValuesColName == "2") ValuesColName <- "POM"
if(ValuesColName == "3") ValuesColName <- "TreeHeight"
# Work only with 1 col to create from the wide format columns
Data <- data.table::melt(Data,
measure.vars = ColToTranspos, # cols to rows (arguments pour lesquels un vecteur est renseigné)
variable.name = ColToTranspos_argname, # name of the new column (length=1) that contains the names of the transposed variables
value.name = ValuesColName) # name of the new column that contains the values of the transposed variables
if(ColToTranspos_argname == "Time"){
Time <- ColToTranspos_argname
}else{
stop(cat("To create the cases where 'Time' is not the variable to transpose"))
}
} # ColToTranspos_argname == 1
View(Data)
### as.numeric
NumVar <- c(Time, Size, PlotArea, X, Y, TreeHeight) # numeric variables
NumVar <- NumVar[!NumVar %in% "none"]
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
View(Data)
library(TreeData)
data(ParacouSubsetWide)
Required_Format <- RequiredFormat(
ParacouSubsetWide,
Plot = "SubPlot",
SubPlot = "SubSubPlot",
Time = c("2016","2017","2018","2019","2020"),
TreeFieldNum = "TreeFieldNum",
IdTree = "idTree",
LifeStatus = "CodeAlive",
Size = "Circ",
SizeUnit = "m",
POM = "MeasCode",
POMUnit = "code",
PlotArea = "PlotArea",
X = "Xutm",
Y = "Yutm",
ScientificName = "none",
VernName = "VernName",
Family = "Family",
Genus = "Genus",
Species = "Species",
CommercialSp = "CommercialSp",
TreeHeight = "none",
TreeHeightUnit = "none")
View(Required_Format)
View(Required_Format)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = c("2016","2017","2018","2019","2020")
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
env
rm(env)
Vars <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, Size, POM, X, Y) # col names (chr)
Vars
Vars <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, Size, POM, X, Y) # col names (chr)
Vars <- Vars[!Vars %in% "none"]
for (v in Vars) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(get(Vars[v])) | get(Vars[v]) == 0, get(Vars[v])]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
View(Data)
View(Data)
MissingVal
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(get(Vars[v])) | get(Vars[v]) == 0, get(Vars[v])]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
View(Data)
MissingVal
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
View(Data)
eval(substitute( # use of argument values as variables
{
Vars <- c(.Plot, .SubPlot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables
{
Vars <- c(.Plot, .SubPlot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
env
View(Data)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = "CensusYear"
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
eval(substitute( # use of argument values as variables
{
Vars <- c(.Plot, .SubPlot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables .SubPlot,
{
Vars <- c(.Plot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables .SubPlot, .Time,
{
Vars <- c(.Plot, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables .SubPlot, .Time, .IdTree,
{
Vars <- c(.Plot, .TreeFieldNum, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
Vars <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, Size, POM, X, Y) # col names (chr)
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE]
# if(any(MissingVal)){ # but have NA values
#   Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
# }
}
}
MissingVal
any(MissingVal)
nrow(MissingVal) > 0
correspondances <- na.omit(unique(Data[, c(IdTree, Plot, SubPlot, TreeFieldNum), with = FALSE])) # with = FALSE: the column names can be used as variables
correspondances
CorresIDs <- correspondances[, IdTree, with = FALSE]
CorresIDs
identical(CorresIDs, unique(CorresIDs))
CorresIDs
unique(CorresIDs)
library(dplyr)
library(data.table)
library(dtplyr)
library(ggplot2)
N <- 10^6
test <- data.frame(species = sample(LETTERS, N, replace = T),
trait = rnorm(N))
dplyr_fun <- function(data, variable, value){
dplyr::filter(data, {{variable}} == value)
}
dt_fun <- function(data, variable, value){
env <- list(.variable = as.name(variable),
.value = value)
eval(substitute(
{
as.data.table(data)[.variable == .value]
}, env))
}
dtplyr_fun <- function(data, variable, value){
data %>%
lazy_dt() %>%
filter({{variable}} == value)
}
install.packages("dtplyr")
library(dtplyr)
dtplyr_fun <- function(data, variable, value){
data %>%
lazy_dt() %>%
filter({{variable}} == value)
}
microbenchmark::microbenchmark(dplyr_fun(test, species, "A"),
dt_fun(test, "species", "A"),
dtplyr_fun(test, species, "A")) %>%
as.data.frame() %>%
ggplot(aes(expr, time)) +
geom_boxplot() +
coord_flip() +
theme_bw()
ids
CorresIDs
duplicated(CorresIDs)
dtplyr_fun(test, species, "A")
N <- 10^6
test <- data.frame(species = sample(LETTERS, N, replace = T),
trait = rnorm(N))
dtplyr_fun <- function(data, variable, value){
data %>%
lazy_dt() %>%
filter({{variable}} == value)
}
dtplyr_fun(test, species, "A")
library(dtplyr)
dtplyr_fun(test, species, "A")
library(dplyr)
dtplyr_fun(test, species, "A")
library(tidyverse)
theme_set(bayesplot::theme_default())
knitr::opts_chunk$set(echo = TRUE)
1 + 2
1 + 2
