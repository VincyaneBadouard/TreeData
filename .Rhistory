for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(as.name(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
# Check for missing coordinates
# missing_coor <- Data[is.na(get(X)) | is.na(get(Y))] # transformer en 1 vect
# if(any(missing_coor)){
#
#   Data[missing_coor, Comment := paste0("Missing coordinates: ",X,", ",Y)]
# }
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(get(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
library(TreeData)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "POM", "Xutm", "Yutm")
v = 7
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(get(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("StandardData") # import data
# INPUTS
Data = StandardData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 2 # number of error to add for each case
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "POM")
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, LifeStatus := NA]
modifs <- c(modifs, modif)
}
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "POM")
modifs <- c()
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, LifeStatus := NA]
modifs <- c(modifs, modif)
}
Data[modifs] # to check
data("StandardData") # import data
# INPUTS
Data = StandardData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 2 # number of error to add for each case
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "POM")
modifs <- c()
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, get(Vars[v]) := NA]
modifs <- c(modifs, modif)
}
v = 1
Vars[v]
get(Vars[v])
Data[modif, get(Vars[v]) := NA]
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Vars[v] := NA]
modifs <- c(modifs, modif)
}
Data[modifs] # to check
View(Data)
data("StandardData") # import data
# INPUTS
Data = StandardData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 2 # number of error to add for each case
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, DBH := 0]
# Data[modif] # to check
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Xutm := NA]
Data[modif, Yutm := NA]
Data[modif] # to check
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "DBH", "LifeStatus", "MeasCode", "Family", "Genus", "Species", "VernName", "ScientificName")
modifs <- c()
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Vars[v] := NA]
modifs <- c(modifs, modif)
}
Data[modifs] # to check
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "MeasCode", "Xutm", "Yutm", "Family", "Genus", "Species", "VernName")
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(get(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "MeasCode", "Xutm", "Yutm", "Family", "Genus", "Species", "VernName")
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(get(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
## code to prepare `TestData` dataset goes here
#### Packages libraries ####
library(TreeData)
library(data.table)
#### Import data ####
data("StandardData") # import data
Data = StandardData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 1 # number of error to add for each case
#### Tree size = 0 ####
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, DBH := 0]
# Data[modif] # to check
#### Missing coordinates ####
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Xutm := NA]
Data[modif, Yutm := NA]
# Data[modif] # to check
#### Other missing values ####
Vars <- c("PlotArea", "Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree",
"DBH", "LifeStatus", "MeasCode", "Family", "Genus", "Species",
"VernName", "ScientificName", "CommercialSp")
modifs <- c()
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Vars[v] := NA]
modifs <- c(modifs, modif)
}
# Data[modifs] # to check
#### Size with bad precision (pas .0 ou .5) ####
wrong <- c(0.2, 0.3, 0.569, 0.8)
modif <- Data[, .I[sample(.N, nError)]]
Data[modif, DBH := DBH + sample(wrong,1)]
# Data[modif] # to check
#### Resurrected tree ####
Last_census <- Data[CensusYear == 2020]
Previous_census <- Data[CensusYear == 2019]
# See if a resurrected tree already exists
MortPrev <- Previous_census[LifeStatus == 0 & IdTree %in% Last_census[LifeStatus == 1, IdTree], IdTree]
# dead in 2019, alive in 2020
Previous_census[IdTree == 101410] # dead
Last_census[IdTree == 101410] # alive
#### Duplicated TreeFieldNum in plot-subplot association ####
modif <- Data[, .I[sample(.N, 1)]] # 1 row to change
duplicatedFieldNum <- Data[!(row.names(Data)) %in% modif & # rows != modif
Plot == Data[modif, Plot] & # same plot as modif
SubPlot == Data[modif, SubPlot], # same subplot as modif
sample(TreeFieldNum,1)] # 1 TreeFieldNum to duplicate
Data[modif, TreeFieldNum := duplicatedFieldNum] # on the row to modif, we duplicate the TreeFieldNum
# Data[TreeFieldNum == duplicatedFieldNum] # to check
#### Duplicated IdTree in a census ####
idModif <- Last_census[, sample(IdTree, nError)] # ne chercher que dans ceux qui ne sont pas à verifier pour eviter de prendre certains avec un duplicatedID # selectionner 2 IdTree à modifier
duplicatedID <- Last_census[!(IdTree %in% idModif), sample(IdTree, 1)] # IdTree != modif
Data[IdTree %in% idModif, IdTree := duplicatedID] # we duplicate the IdTree on the previous selected IdTree
Data[CensusYear == 2020 & IdTree == duplicatedID] # to check
#### Unseen tree but alive tree after ####
#### Abnomal growth ####
#### Abnomal recruit ####
#### Save this test data in the package ####
TestData <- Data
usethis::use_data(TestData, overwrite = TRUE)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "MeasCode", "Xutm", "Yutm", "Family", "Genus", "Species", "VernName")
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(get(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
Vars <- c("DBH", "POM", "TreeHeight", "StemHeight")
if(Vars[v] %in% names(Data)){ # If the column exists
Data[get(Vars[v]) == 0,
"Comment" := paste0(Vars[v],"cannot be 0")] # comments
}
Data[!is.na(Comment)] # to check
View(Data)
Data[DBH == 0]
Data[Vars == 0]
Data[get(Vars) == 0]
Vars[v] %in% names(Data)
Vars[v]
v =1
Vars[v] %in% names(Data)
Data[get(Vars[v]) == 0,
"Comment" := paste0(Vars[v],"cannot be 0")] # comments
Data[get(Vars) == 0]
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "MeasCode", "Xutm", "Yutm", "Family", "Genus", "Species", "VernName")
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(get(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check (13 comments)
Vars <- c("DBH", "POM", "TreeHeight", "StemHeight")
if(Vars[v] %in% names(Data)){ # If the column exists
Data[get(Vars[v]) == 0,
"Comment" := paste0(Vars[v]," cannot be 0")] # comments
}
Data[get(Vars) == 0] # to check
Vars <- c("DBH", "POM", "TreeHeight", "StemHeight")
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[get(Vars[v]) == 0,
"Comment" := paste0(Vars[v]," cannot be 0")] # comments
}
}
Data[get(Vars) == 0] # to check
Data[!is.na(Comment)] # to check (13 comments)
anyDuplicated(Data)
anyDuplicated(Data)== 0
# Check of the unique association of the IdTree with Plot, SubPlot and TreeFieldNum
correspondances <- na.omit(unique(Data[, c(IdTree, Plot, SubPlot, TreeFieldNum), with = FALSE])) # with=F: the column names can be used as variables
correspondances <- na.omit(unique(Data[, get(c(IdTree, Plot, SubPlot, TreeFieldNum))]))
correspondances <- na.omit(unique(Data[, get(c("IdTree", "Plot", "SubPlot", "TreeFieldNum"))]))
correspondances
Data[, get(c("IdTree", "Plot", "SubPlot", "TreeFieldNum"))]
Data[, get(.("IdTree", "Plot", "SubPlot", "TreeFieldNum"))]
Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)]
na.omit(unique(Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)]))
correspondances <- na.omit(unique(Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)])) # without NA
correspondances[, IdTree]
length(correspondances[, IdTree])
length(unique(correspondances[, IdTree]))
CorresIDs <- correspondances[, IdTree] # all the possible idtree's
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same lenght, same ids -> 1 asso/ID
Data[duplicated(CorresIDs),
Comment := paste0("Non-unique association of the ",IdTree," with " ,Plot,", ",SubPlot," and " ,TreeFieldNum)]
}
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same lenght, same ids -> 1 asso/ID
Data[duplicated(CorresIDs),
Comment := paste0("Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum")]
}
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same lenght, same ids -> 1 asso/ID
Data[duplicated(CorresIDs),
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
!identical(CorresIDs, unique(CorresIDs))
Data[duplicated(CorresIDs)]
duplicated(CorresIDs)
correspondances <- unique(Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)])
correspondances
View(correspondances)
correspondances <- unique(Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)])
CorresIDs <- correspondances[, IdTree] # all the possible idtree's
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same lenght, same ids -> 1 asso/ID
Data[duplicated(CorresIDs),
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
Data[duplicated(CorresIDs)]
CorresIDs
duplicated(CorresIDs)
length(CorresIDs)
length(duplicated(CorresIDs))
duplicated(CorresIDs)
Data[isTRUE(duplicated(CorresIDs))]
isTRUE(duplicated(CorresIDs))
Data[duplicated(CorresIDs)== TRUE]
duplicated(CorresIDs)== TRUE
CorresIDs
length(CorresIDs)
length(unique(CorresIDs))
Data[!duplicated(CorresIDs$IdTree)]
CorresIDs <- correspondances[, .(IdTree)] # all the possible idtree's
CorresIDs
!identical(CorresIDs, unique(CorresIDs))
CorresIDs
unique(CorresIDs)
!identical(CorresIDs, unique(CorresIDs))
Data[!duplicated(CorresIDs$IdTree)]
duplicated(CorresIDs$IdTree)
# temp <- apured_trees # on 1 census
temp = Data
# Create "PlotSubNum" = "Plot/SubPlot/TreeFieldNum"
temp$PlotSubNum <- paste(temp$Plot, temp$SubPlot, temp$TreeFieldNum, sep="/")
View(temp)
anyDuplicated(temp$PlotSubNum) != 0
# if any duplicats in this col
if(anyDuplicated(temp$PlotSubNum) != 0) {
# For each plot
for (p in unique(temp$Plot)) {
# For each SubPlot in this plot
for (c in unique(temp[temp$Plot==p, "SubPlot"])) {
num <- temp[temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
condition <- eval(parse(text = "temp$Plot==p & temp$SubPlot==c & temp$TreeFieldNum %in% duplicated_num"))
# "NumArbre duplique dans une même parcelle et un même carre"
}
}
}
}
num
num <- c()
duplicated_num <- num <- c()
# if any duplicats in this col
if(anyDuplicated(temp$PlotSubNum) != 0) {
# For each plot
for (p in unique(temp$Plot)) {
# For each SubPlot in this plot
for (c in unique(temp[temp$Plot==p, "SubPlot"])) {
num <- temp[temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
# condition <- eval(parse(text = "temp$Plot==p & temp$SubPlot==c & temp$TreeFieldNum %in% duplicated_num"))
# "NumArbre duplique dans une même parcelle et un même carre"
}
}
}
}
num
duplicated_num <- num <- vector("character")
duplicated_num
num
# if any duplicats in this col
if(anyDuplicated(temp$PlotSubNum) != 0) {
# For each plot
for (p in unique(temp$Plot)) {
# For each SubPlot in this plot
for (c in unique(temp[temp$Plot==p, "SubPlot"])) {
num <- temp[temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
# condition <- eval(parse(text = "temp$Plot==p & temp$SubPlot==c & temp$TreeFieldNum %in% duplicated_num"))
# "NumArbre duplique dans une même parcelle et un même carre"
}
}
}
}
# temp <- apured_trees # on 1 census
temp = Data
# temp <- apured_trees # on 1 census
temp = Data
# Create "PlotSubNum" = "Plot/SubPlot/TreeFieldNum"
temp$PlotSubNum <- paste(temp$Plot, temp$SubPlot, temp$TreeFieldNum, sep="/")
duplicated_num <- num <- vector("character")
anyDuplicated(temp$PlotSubNum) != 0
unique(temp$Plot)
na.omit(unique(temp$Plot))
!is.na(unique(temp$Plot)
)
unique(temp$Plot)
unique(temp$Plot, na.rm=TRUE)
na.omit(unique(temp$Plot)))
na.omit(unique(temp$Plot))
unique(na.omit(temp$Plot)))
unique(na.omit(temp$Plot))
unique(na.omit(temp[temp$Plot==p, "SubPlot"]))
unique(na.omit(temp[temp$Plot==1, "SubPlot"]))
# if any duplicats in this col
if(anyDuplicated(temp$PlotSubNum) != 0) {
# For each plot
for (p in unique(na.omit(temp$Plot))) {
# For each SubPlot in this plot
for (c in unique(na.omit(temp[temp$Plot==p, "SubPlot"]))) {
num <- temp[temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
# condition <- eval(parse(text = "temp$Plot==p & temp$SubPlot==c & temp$TreeFieldNum %in% duplicated_num"))
# "NumArbre duplique dans une même parcelle et un même carre"
}
}
}
}
num
anyDuplicated(num)
unique(num[duplicated(num)])
duplicated_num <- num <- vector("character")
p=1
c= 1
temp[temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum
anyDuplicated(num)
c= 2
num <- temp[temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # TreeFieldNum for each Plot-SubPlot combination
anyDuplicated(num)
unique(num[duplicated(num)])
num
anyDuplicated(num)
duplicated(num)
num[duplicated(num)]
unique(num[duplicated(num)])
# temp <- apured_trees # on 1 census
temp = Data
# Create "PlotSubNum" = "Plot/SubPlot/TreeFieldNum"
temp$PlotSubNum <- paste(temp$CensusYear, temp$Plot, temp$SubPlot, temp$TreeFieldNum, sep="/")
View(temp)
y = 2019
num <- temp[temp$CensusYear==y & temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
num
anyDuplicated(num)
c= 1
num <- temp[temp$CensusYear==y & temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
anyDuplicated(num)
c= 3
anyDuplicated(num)
c= 4
num <- temp[temp$CensusYear==y & temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
anyDuplicated(num)
duplicated_num <- num <- vector("character")
# if any duplicats in this col
if(anyDuplicated(temp$PlotSubNum) != 0) {
# For each census
for (y in unique(na.omit(temp$CensusYear))) {
# For each plot
for (p in unique(na.omit(temp$Plot))) {
# For each SubPlot in this plot
for (c in unique(na.omit(temp[temp$Plot==p, "SubPlot"]))) {
num <- temp[temp$CensusYear==y & temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
# condition <- eval(parse(text = "temp$Plot==p & temp$SubPlot==c & temp$TreeFieldNum %in% duplicated_num"))
# "NumArbre duplique dans une même parcelle et un même carre"
}
}
}
}
}
duplicated_num
unique(num[duplicated(num)])
num
unique(num[duplicated(num)])
duplicated_num
temp[TreeFieldNum == duplicated_num,
Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
temp[TreeFieldNum == duplicated_num]
# temp <- apured_trees # on 1 census
temp = Data
# Create "PlotSubNum" = "Plot/SubPlot/TreeFieldNum"
temp$PlotSubNum <- paste(temp$CensusYear, temp$Plot, temp$SubPlot, temp$TreeFieldNum, sep="/")
# y = 2019
# p=1
# c= 4
duplicated_num <- num <- vector("character")
# if any duplicats in this col
if(anyDuplicated(temp$PlotSubNum) != 0) {
# For each census
for (y in unique(na.omit(temp$CensusYear))) {
# For each plot
for (p in unique(na.omit(temp$Plot))) {
# For each SubPlot in this plot
for (c in unique(na.omit(temp[temp$Plot==p, "SubPlot"]))) {
num <- temp[temp$CensusYear==y & temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
temp[TreeFieldNum == duplicated_num,
Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
temp[TreeFieldNum == duplicated_num]
# condition <- eval(parse(text = "temp$Plot==p & temp$SubPlot==c & temp$TreeFieldNum %in% duplicated_num"))
# "NumArbre duplique dans une même parcelle et un même carre"
}
}
}
}
}
