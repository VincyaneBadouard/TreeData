DBHRange = 10 # (numeric, 1 value) in cm
MinIndividualNbr = 5
DefaultPOM = 1.3 # (numeric, 1 value) in m
Pioneers = c("Cecropia","Pourouma") # verna or scfic names ? (characters vector)
PioneersTreshold = 7.5  # (numeric, 1 value) in cm
IgnorePOM = FALSE # (logical) est-ce que je garde ? on le prend s'il existe
DetectOnly = FALSE # (logical)
# Create data
## With regular time between census
# Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
#                    Year = rep(seq(2000,2016, by = 2), 4), # 9 DBH values each (2 years between 2 census)
#                    DBH  = c(13:21), # 1 cm/census (0.5 cm/year)
#                    POM = 0) # default POM
## With irregular time between census
Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
Year = rep(c(seq(2000,2008, by = 2), 2012, 2014,2016, 2020), 4), # 9 DBH values each (2 years between 2 census)
DBH  = c(13:17, 19:21, 23), # 0.5 cm/year
POM = 0, # default POM
HOM = 1.3) # default HOM
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# Create errors
Data <- Data[order(IdTree, Year)]
## 1 punctual error : growth > 5 cm DBH/year
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2008, 16+(5*2)+4, DBH)]
## 1 punctual error : growth < -2 cm DBH/census
Data[IdTree %in% "b", DBH := ifelse(Year %in% 2008, 16-4, DBH)]
## 2 punctual errors : growth > 5 cm DBH/year & growth < -2 cm DBH/census
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2014, 19-4, DBH)]
## 2 shift error with available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "c" & Year %in% c(2008:2014), ("POM") := 1]
Data[IdTree %in% "c" & Year %in% c(2016:2020), ("POM") := 2]
Data[POM %in% 1, ("DBH") := c(16-4, (16-4)+2, (16-4)+3)] # 1st shift, always 0.5cm/yearr
Data[POM %in% 2, ("DBH") := c(15-4, (15-4)+2)] # 2nd shift, always 0.5cm/year
## 2 shift error without available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "d", ("POM") := NA] # no POM
Data[IdTree %in% "d" & Year %in% c(2008:2020), ("DBH") := c(16-4, (16-4)+2, (16-4)+3, (16-4)+4, (16-4)+6)] # only 1 shift
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# 1 ind at a time
id <- "c"
IdTree <- unique(Data[IdTree %in% id, IdTree])
DBHCor <- DBH <- Data[IdTree %in% id, DBH]
Time <- Data[IdTree %in% id, Year]
POM <- Data[IdTree %in% id, POM]
View(Data)
## 2 shift error without available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "d", c("POM", "HOM") := NA] # no POM
View(Data)
Data[IdTree %in% "c" & Year %in% c(2008:2014), c("POM", "HOM") := list(1, 2.3)]
Data[IdTree %in% "c" & Year %in% c(2016:2020), c("POM", "HOM") := list(3, 5.3)]
View(Data)
# Create data
## With regular time between census
# Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
#                    Year = rep(seq(2000,2016, by = 2), 4), # 9 DBH values each (2 years between 2 census)
#                    DBH  = c(13:21), # 1 cm/census (0.5 cm/year)
#                    POM = 0) # default POM
## With irregular time between census
Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
Year = rep(c(seq(2000,2008, by = 2), 2012, 2014,2016, 2020), 4), # 9 DBH values each (2 years between 2 census)
DBH  = c(13:17, 19:21, 23), # 0.5 cm/year
POM = 0, # default POM
HOM = 1.3) # default HOM
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# Create errors
Data <- Data[order(IdTree, Year)]
## 1 punctual error : growth > 5 cm DBH/year
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2008, 16+(5*2)+4, DBH)]
## 1 punctual error : growth < -2 cm DBH/census
Data[IdTree %in% "b", DBH := ifelse(Year %in% 2008, 16-4, DBH)]
## 2 punctual errors : growth > 5 cm DBH/year & growth < -2 cm DBH/census
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2014, 19-4, DBH)]
## 2 shift error with available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "c" & Year %in% c(2008:2014), c("POM", "HOM") := list(1, 2.3)]  # POM = 1, HOM = 2.3m
Data[IdTree %in% "c" & Year %in% c(2016:2020), c("POM", "HOM") := list(3, 5.3)]
Data[POM %in% 1, ("DBH") := c(16-4, (16-4)+2, (16-4)+3)] # 1st shift, always 0.5cm/yearr
Data[POM %in% 2, ("DBH") := c(15-4, (15-4)+2)] # 2nd shift, always 0.5cm/year
## 2 shift error without available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "d", c("POM", "HOM") := NA] # no POM
Data[IdTree %in% "d" & Year %in% c(2008:2020), ("DBH") := c(16-4, (16-4)+2, (16-4)+3, (16-4)+4, (16-4)+6)] # only 1 shift
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# 1 ind at a time
id <- "c"
IdTree <- unique(Data[IdTree %in% id, IdTree])
DBHCor <- DBH <- Data[IdTree %in% id, DBH]
Time <- Data[IdTree %in% id, Year]
POM <- Data[IdTree %in% id, POM]
# Create data
## With regular time between census
# Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
#                    Year = rep(seq(2000,2016, by = 2), 4), # 9 DBH values each (2 years between 2 census)
#                    DBH  = c(13:21), # 1 cm/census (0.5 cm/year)
#                    POM = 0) # default POM
## With irregular time between census
Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
Year = rep(c(seq(2000,2008, by = 2), 2012, 2014,2016, 2020), 4), # 9 DBH values each (2 years between 2 census)
DBH  = c(13:17, 19:21, 23), # 0.5 cm/year
POM = 0, # default POM
HOM = 1.3) # default HOM
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# Create errors
Data <- Data[order(IdTree, Year)]
## 1 punctual error : growth > 5 cm DBH/year
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2008, 16+(5*2)+4, DBH)]
## 1 punctual error : growth < -2 cm DBH/census
Data[IdTree %in% "b", DBH := ifelse(Year %in% 2008, 16-4, DBH)]
## 2 punctual errors : growth > 5 cm DBH/year & growth < -2 cm DBH/census
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2014, 19-4, DBH)]
## 2 shift error with available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "c" & Year %in% c(2008:2014), c("POM", "HOM") := list(1, 2.3)]  # POM = 1, HOM = 2.3m
Data[IdTree %in% "c" & Year %in% c(2016:2020), c("POM", "HOM") := list(2, 5.3)]
Data[POM %in% 1, ("DBH") := c(16-4, (16-4)+2, (16-4)+3)] # 1st shift, always 0.5cm/yearr
Data[POM %in% 2, ("DBH") := c(15-4, (15-4)+2)] # 2nd shift, always 0.5cm/year
## 2 shift error without available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "d", c("POM", "HOM") := NA] # no POM
Data[IdTree %in% "d" & Year %in% c(2008:2020), ("DBH") := c(16-4, (16-4)+2, (16-4)+3, (16-4)+4, (16-4)+6)] # only 1 shift
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# 1 ind at a time
id <- "c"
IdTree <- unique(Data[IdTree %in% id, IdTree])
DBHCor <- DBH <- Data[IdTree %in% id, DBH]
Time <- Data[IdTree %in% id, Year]
POM <- Data[IdTree %in% id, POM]
# Create data
## With regular time between census
# Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
#                    Year = rep(seq(2000,2016, by = 2), 4), # 9 DBH values each (2 years between 2 census)
#                    DBH  = c(13:21), # 1 cm/census (0.5 cm/year)
#                    POM = 0) # default POM
## With irregular time between census
Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
Year = rep(c(seq(2000,2008, by = 2), 2012, 2014,2016, 2020), 4), # 9 DBH values each (2 years between 2 census)
DBH  = c(13:17, 19:21, 23), # 0.5 cm/year
POM = 0, # default POM
HOM = 1.3) # default HOM
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# Create errors
Data <- Data[order(IdTree, Year)]
## 1 punctual error : growth > 5 cm DBH/year
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2008, 16+(5*2)+4, DBH)]
## 1 punctual error : growth < -2 cm DBH/census
Data[IdTree %in% "b", DBH := ifelse(Year %in% 2008, 16-4, DBH)]
## 2 punctual errors : growth > 5 cm DBH/year & growth < -2 cm DBH/census
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2014, 19-4, DBH)]
## 2 shift error with available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "c" & Year %in% c(2008:2014), c("POM", "HOM") := list(1, 2.3)]  # POM = 1, HOM = 2.3m
Data[IdTree %in% "c" & Year %in% c(2016:2020), c("POM", "HOM") := list(2, 5.3)]
Data[POM %in% 1, ("DBH") := c(16-4, (16-4)+2, (16-4)+3)] # 1st shift, always 0.5cm/yearr
Data[POM %in% 2, ("DBH") := c(15-4, (15-4)+2)] # 2nd shift, always 0.5cm/year
## 2 shift error without available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "d", c("POM", "HOM") := NA] # no POM
Data[IdTree %in% "d" & Year %in% c(2008:2020), ("DBH") := c(16-4, (16-4)+2, (16-4)+3, (16-4)+4, (16-4)+6)] # only 1 shift
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# 1 ind at a time
id <- "c"
IdTree <- unique(Data[IdTree %in% id, IdTree])
DBHCor <- DBH <- Data[IdTree %in% id, DBH]
Time <- Data[IdTree %in% id, Year]
POM <- Data[IdTree %in% id, POM]
DataTree <- Data[IdTree %in% id]
View(DataTree)
View(DataTree)
# check if the HOM column exists
if(!"HOM" %in% names(Data)){
stop("you have chosen to make a 'taper' correction,
but you do not have the necessary 'HOM' column in your dataset")
}
any(DataTree[HOM > DefaultPOM])
DataTree[HOM > DefaultPOM]
if(any(DataTree[,HOM] > DefaultPOM)){ # if some measurements of the tree were made above the POM by default
Data <- GenerateComment(Data,
condition = (DataTree[,HOM] > DefaultPOM),
comment = paste0("HOM different from the default HOM"))
if(DetectOnly %in% FALSE){
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DBH, HOM, TaperParameter(DBH, HOM))]
}
}
any(DataTree[,HOM] > DefaultPOM)
Data <- GenerateComment(Data,
condition = (DataTree[,HOM] > DefaultPOM),
comment = paste0("HOM different from the default HOM"))
DataTree[,HOM] > DefaultPOM
Data <- GenerateComment(Data,
condition = (DataTree[,HOM] > DefaultPOM),
comment = paste0("HOM different from the default HOM"))
DataTree <- GenerateComment(Data,
condition = (DataTree[,HOM] > DefaultPOM),
comment = paste0("HOM different from the default HOM"))
DataTree <- GenerateComment(DataTree,
condition = (DataTree[,HOM] > DefaultPOM),
comment = paste0("HOM different from the default HOM"))
View(DataTree)
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DBH, HOM, TaperParameter(DBH, HOM))]
TaperFormula = function(DAB, HOM, TaperParameter) DAB / (2 * exp(- TaperParameter(HOM - 1.3))) # Cushman et al.2021 (function)
TaperFormula = function(DAB, HOM, TaperParameter) DAB / (2 * exp(- TaperParameter(HOM - 1.3))) # Cushman et al.2021 (function)
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DBH, HOM, TaperParameter(DBH, HOM))]
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DataTree$DBH, DataTree$HOM,
TaperParameter(DataTree$DBH, DataTree$HOM))]
TaperFormula(DataTree$DBH, DataTree$HOM,
TaperParameter(DataTree$DBH, DataTree$HOM)
)
DataTree$HOM
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DataTree$DBH, DataTree$HOM,
TaperParameter(DataTree$DBH, HOM = DataTree$HOM))]
TaperParameter(DataTree$DBH, HOM = DataTree$HOM)
HOM <- Data[IdTree %in% id, HOM]
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DBH, HOM = HOM,
TaperParameter = TaperParameter(DBH, HOM = HOM))]
TaperParameter(DBH, HOM = HOM)
TaperParameter = TaperParameter(DBH, HOM = HOM)
TaperFormula(DBH, HOM = HOM,
TaperParameter)
TaperParameter
TaperFormula = function(DAB, HOM, TaperParameter) DAB / (2 * exp(- TaperParameter*(HOM - 1.3))) # Cushman et al.2021 (function)
TaperParameter = function(DAB, HOM) 0.156 - 0.023 * log(DAB) - 0.021 * log(HOM) # Cushman et al.2021 (function)
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DBH, HOM = HOM,
TaperParameter = TaperParameter(DBH, HOM = HOM))]
View(DataTree)
# Create data
## With regular time between census
# Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
#                    Year = rep(seq(2000,2016, by = 2), 4), # 9 DBH values each (2 years between 2 census)
#                    DBH  = c(13:21), # 1 cm/census (0.5 cm/year)
#                    POM = 0) # default POM
## With irregular time between census
Data <- data.table(IdTree = c("a", "b", "c", "d"), # 4 ind
Year = rep(c(seq(2000,2008, by = 2), 2012, 2014,2016, 2020), 4), # 9 DBH values each (2 years between 2 census)
DBH  = c(13:17, 19:21, 23), # 0.5 cm/year
POM = 0, # default POM
HOM = 1.3) # default HOM
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# Create errors
Data <- Data[order(IdTree, Year)]
## 1 punctual error : growth > 5 cm DBH/year
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2008, 16+(5*2)+4, DBH)]
## 1 punctual error : growth < -2 cm DBH/census
Data[IdTree %in% "b", DBH := ifelse(Year %in% 2008, 16-4, DBH)]
## 2 punctual errors : growth > 5 cm DBH/year & growth < -2 cm DBH/census
Data[IdTree %in% "a", DBH := ifelse(Year %in% 2014, 19-4, DBH)]
## 2 shift error with available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "c" & Year %in% c(2008:2014), c("POM", "HOM") := list(1, 1.5)]  # POM = 1, HOM = 2.3m
Data[IdTree %in% "c" & Year %in% c(2016:2020), c("POM", "HOM") := list(2,2)]
Data[POM %in% 1, ("DBH") := c(16-4, (16-4)+2, (16-4)+3)] # 1st shift, always 0.5cm/yearr
Data[POM %in% 2, ("DBH") := c(15-4, (15-4)+2)] # 2nd shift, always 0.5cm/year
## 2 shift error without available POM : growth < -2 cm DBH/census with no return to normal
Data[IdTree %in% "d", c("POM", "HOM") := NA] # no POM
Data[IdTree %in% "d" & Year %in% c(2008:2020), ("DBH") := c(16-4, (16-4)+2, (16-4)+3, (16-4)+4, (16-4)+6)] # only 1 shift
# check their growth
ggplot(Data) +
aes(x = Year, y = DBH) +
geom_line(size = 0.5, colour = "#46337E") +
geom_point(shape = "circle", size = 1.5, colour = "#112446") +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free")
# 1 ind at a time
id <- "c"
DataTree <- Data[IdTree %in% id]
IdTree <- unique(Data[IdTree %in% id, IdTree])
DBHCor <- DBH <- Data[IdTree %in% id, DBH]
Time <- Data[IdTree %in% id, Year]
POM <- Data[IdTree %in% id, POM]
HOM <- Data[IdTree %in% id, HOM]
# check if the HOM column exists
if(!"HOM" %in% names(Data)){
stop("you have chosen to make a 'taper' correction,
but you do not have the necessary 'HOM' column in your dataset")
}
if(any(DataTree[,HOM] > DefaultPOM)){ # if some measurements of the tree were made above the POM by default
DataTree <- GenerateComment(DataTree,
condition = (DataTree[,HOM] > DefaultPOM),
comment = paste0("HOM different from the default HOM"))
if(DetectOnly %in% FALSE){
# Apply taper correction
DataTree[HOM > DefaultPOM, DBHCor := TaperFormula(DBH, HOM = HOM,
TaperParameter = TaperParameter(DBH, HOM = HOM))]
}
}
View(DataTree)
# Apply taper correction
DataTree[HOM == DefaultPOM, DBHCor := ifelse(is.na(DBHCor), DBH, DBHCor)] # At default POM, keep the measured value
View(DataTree)
load("C:/Users/Utilisateur/AppData/Local/ProjetsR/TreeData/data/ParacouSubset.rda")
View(Data)
View(DataTree)
View(TestData)
DataTree[HOM > DefaultPOM, DBHCor := round(TaperFormula(DAB = DBH,
HOM = HOM,
TaperParameter = TaperParameter(DAB = DBH, HOM = HOM)),
dixit = 1)
]
DataTree[HOM > DefaultPOM, DBHCor := round(TaperFormula(DAB = DBH,
HOM = HOM,
TaperParameter = TaperParameter(DAB = DBH, HOM = HOM)),
digits = 1)
]
View(DataTree)
DataTree[HOM > DefaultPOM & !is.na(DBHCor), DiameterCorrectionMeth := "taper"]
View(DataTree)
# 1 ind at a time
id <- "a"
IdTree <- unique(Data[IdTree %in% id, IdTree])
DBHCor <- DBH <- Data[IdTree %in% id, DBH]
Time <- Data[IdTree %in% id, Year]
POM <- Data[IdTree %in% id, POM]
# Update cresc (for the i loop)
cresc <- cresc_abs <- rep(0, length(DBHCor) - 1) # (cresc[1] corresponds to the 2nd DBH)
cresc[which(!is.na(DBHCor))[-1] - 1] <-
diff(DBHCor[!is.na(DBHCor)]) / diff(Time[!is.na(DBHCor)])
cresc_abs[which(!is.na(DBHCor))[-1] - 1] <- diff(DBHCor[!is.na(DBHCor)])
# 1 ind at a time
id <- "a"
IdTree <- unique(Data[IdTree %in% id, IdTree])
DBHCor <- DBH <- Data[IdTree %in% id, DBH]
Time <- Data[IdTree %in% id, Year]
POM <- Data[IdTree %in% id, POM]
# Update cresc (for the i loop)
cresc <- cresc_abs <- rep(0, length(DBHCor) - 1) # (cresc[1] corresponds to the 2nd DBH)
cresc[which(!is.na(DBHCor))[-1] - 1] <-
diff(DBHCor[!is.na(DBHCor)]) / diff(Time[!is.na(DBHCor)])
cresc_abs[which(!is.na(DBHCor))[-1] - 1] <- diff(DBHCor[!is.na(DBHCor)])
####    if there is a DBH change > 5cm/year or < -2 cm   ####
### do as many corrections as there are abnormal DBH change values ###
Ncresc_abn = sum(cresc >= PositiveGrowthThreshold | cresc_abs < NegativeGrowthThreshold) # nbr of abnormal values
# le retour à la normale est considéré comme une erreur (perte excessive)
if (Ncresc_abn > 0) { # if there are abnormal values
for (i in 1:Ncresc_abn) { # for each abnormal value
# begin with the census with the highest DBH change
cresc_abn = which(cresc >= PositiveGrowthThreshold | cresc_abs < NegativeGrowthThreshold) # quels sont les concernés
ab <- cresc_abn[which.max(abs(cresc[cresc_abn]))] # the highest absolute DBH increment (celui qui a initié) (ab in cresc indices)
if (length(ab) == 1) {
# values surrounding ab
surround = c(ab - 2, ab - 1, ab + 1, ab + 2) # the 4 values, 2 before & 2 after the error
# that have a meaning (no NAs or 0 values)
surround = surround[surround > 0 &
surround <= length(cresc)] # de taille maximale [0;longueur de l'incrémentation = length(dbh) -1)]
# moment of max and min DBH changes around ab (including ab, that should be one of the 2)
sourround_ab = sort(c(surround, ab)) # ab and its 4 values around in the increasing order
up = sourround_ab[which.max(cresc[sourround_ab])] # l'incrémentation max de cette série
down = sourround_ab[which.min(cresc[sourround_ab])] # l'incrémentation min de cette série
if (length(surround) > 0) {  # if there are values around ab
# 1st case : excessive increase/decrease offset by a similar decrease in dbh, plus 5cm/yr
# is there a value that could compensate the excessive DBH change?
# check if removing those values would solve the problem (ie cresc < 5 & cresc_abs > -2 )
if (isTRUE(down > up & cresc[up] * cresc[down] < 0 &
# first the most important increase and then the most important decrease of the DBH
# cresc and down are cresc indices, to have the corresponding DBH index add +1
(DBHCor[down + 1] - DBHCor[up]) / (Time[down + 1] - Time[up]) <= PositiveGrowthThreshold &
DBHCor[down + 1] - DBHCor[up] >= NegativeGrowthThreshold) | # Nino a mis un else plutot qu'un "ou" (ce qui semble mieux)
isTRUE(up > down & cresc[up] * cresc[down] < 0 &
# first the most important decrease and then the most important increase of the DBH
(DBHCor[up + 1] - DBHCor[down]) / (Time[up + 1] - Time[down]) <= PositiveGrowthThreshold &
DBHCor[up + 1] - DBHCor[down] >= -NegativeGrowthThreshold)) { # different de Nino (tag dirtyhack) (runner ac mon ex)
# correction: abnormal values are deleted and will be replaced later on (see missing)
first <- min(up, down) + 1 # the first value with the highest increment (positive or negative) (+1 to switch from cresc to DBH indices)
last <- max(up, down) # the last value with the highest increment (positive or negative) (in cresc indices, -1 to get the DBH index)
# first and last is the same value if the error is compensated immediately
DBHCor[first:last] <- NA # put NA de la 1ere valeur à haut changement, à la dernière valeur à haut changement
} # if it's a ponctual error
} # if there are values around ab
## If only 2 values, with abnormal difference
if (length(DBHCor[!is.na(DBHCor)]) == 2 & i==1){ # i =  chaque valeur aberrante
# trust the 2nd one
DBHCor[!is.na(DBHCor)][1] <- DBHCor[!is.na(DBHCor)][2]
}
# Update cresc (for the i loop)
cresc <- cresc_abs <- rep(0, length(DBHCor) - 1) # (cresc[1] corresponds to the 2nd DBH)
if (sum(!is.na(DBHCor)) > 1) { # if there is at least 1 measurement
cresc[which(!is.na(DBHCor))[-1] - 1] <-
diff(DBHCor[!is.na(DBHCor)]) / diff(Time[!is.na(DBHCor)])
cresc_abs[which(!is.na(DBHCor))[-1] - 1] <- diff(DBHCor[!is.na(DBHCor)])
}
} # length(ab) == 1
} # i loop end
} # if there are abnormal values
Y = DBHCor
miss <- which(is.na(Y)) # DBH = NA -> value to replace
miss
Y[miss] <- sapply(miss, function(i) { # i = each value de miss
# case 1: i is the first value of the series
if (i < min(which(!is.na(Y)))) {
## choose 2 next values
yval <- Y[which(!is.na(Y))[1:min(2, sum(!is.na(Y)))]] # DBH de la 1ere val non-NA à la 2nde si elle existe
tval <- Time[which(!is.na(Y))[1:min(2, sum(!is.na(Y)))]] # les années concernées de ces 2 val
}
#case 2: i is the last value of the series
else if (i > max(which(!is.na(Y)))) {
yval <- Y[which(!is.na(Y))[(sum(!is.na(Y)) - 1):sum(!is.na(Y))]] # DBH de l'avant-derniere val non-NA à la dernière
tval <-
Time[which(!is.na(Y))[(sum(!is.na(Y)) - 1):sum(!is.na(Y))]] # années concernées
yval <- yval[!is.na(yval)] # s'assurer que ce sont des non-NA
tval <- tval[!is.na(yval)]
}
# case 3: i is in the middle of the series
else {
yval <-
Y[c(max(which(!is.na(Y[1:(i - 1)]))), i + min(which(!is.na(Y[(i + 1):length(Y)]))))] # DBH
# prendre la valeur la plus récente non-NA avant le NA, et la prochaine valeur non-NA après le NA = prendre les valeurs encadrantes non-NA les plus proches du NA
tval <-
Time[c(max(which(!is.na(Y[1:(i - 1)]))), i + min(which(!is.na(Y[(i + 1):length(Y)]))))] # années concernées
}
# Linear regression: DBH ~ years
reg <- lm(yval ~ tval)$coef # extract the coefs
yi <- reg[1] + reg[2] * Time[i] # (y = b + ax),  DBHi = b + a YEARi
if (sum(!is.na(tval)) == 1) { # s'il n'y a qu'1 valeur non-anormale
yi <- yval # le DBH à corriger prends la valeur de l'unique DBH non-anormal
}
return(yi) # DBH of i, yi -> Y[miss]
}) # sapply end (for each i)
reg
yi
i < min(which(!is.na(Y)))
i > max(which(!is.na(Y)))
yval
yval <-
Y[c(max(which(!is.na(Y[1:(i - 1)]))), i + min(which(!is.na(Y[(i + 1):length(Y)]))))] # DBH
# prendre la valeur la plus récente non-NA avant le NA, et la prochaine valeur non-NA après le NA = prendre les valeurs encadrantes non-NA les plus proches du NA
tval <-
Time[c(max(which(!is.na(Y[1:(i - 1)]))), i + min(which(!is.na(Y[(i + 1):length(Y)]))))] # années concernées
# case 3: i is in the middle of the series
else {
# Linear regression: DBH ~ years
reg <- lm(yval ~ tval)$coef # extract the coefs
yi <- reg[1] + reg[2] * Time[i] # (y = b + ax),  DBHi = b + a YEARi
reg
yi <- reg[1] + reg[2] * Time[i] # (y = b + ax),  DBHi = b + a YEARi
yi
sum(!is.na(tval)) == 1
yi
lm(yval ~ poly(tval, 2))
yval
tval
lm(yval ~ poly(tval, 2))
yval
# Degree 2 polynomial regression
reg <- lm(DBHCor ~ poly(Time, 2)) # 'degree' must be less than number of unique points
reg
reg
# Linear regression: DBH ~ years
reg <- lm(yval ~ tval)$coef # extract the coefs
reg
# Degree 2 polynomial regression
reg <- lm(yval ~ poly(tval, 2)) # 'degree' must be less than number of unique points
# Degree 2 polynomial regression
reg <- lm(DBHCor ~ poly(Time, 2)) # 'degree' must be less than number of unique points
reg
yi <- reg[1] + reg[2] * Time[i] + reg[3] * Time[i]^2 # (y = b + ax + cx^2),  DBHi = b + a YEARi + c YEARi^2
reg[1]
reg[2]
# Degree 2 polynomial regression
reg <- lm(DBHCor ~ poly(Time, 2))$coef # 'degree' must be less than number of unique points
yi <- reg[1] + reg[2] * Time[i] + reg[3] * Time[i]^2 # (y = b + ax + cx^2),  DBHi = b + a YEARi + c YEARi^2
yi
