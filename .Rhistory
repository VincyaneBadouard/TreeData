Data[, c("Genus", "Species") := tstrsplit(ScientificName, SfcnameSep, fixed = TRUE)]
}
### ScientificName (if Genus & Species exist)
if(!ScientificName %in% names(Data) & all(c(Genus, Species) %in% names(Data))) # or ScientificName == "none"
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
# Columns renaming Data[, new = old]
Data[, Plot = .Plot]
Data[, SubPlot = .Plot]
Data[, Time = .Plot]
Data[, TreeFieldNum = .TreeFieldNum]
Data[, IdTree = .IdTree]
Data[, LifeStatus = .LifeStatus]
Data[, Size = .Size]
Data[, POM = .POM]
Data[, Plot = .Plot]
Data[, PlotArea = .PlotArea]
Data[, Xutm = .X]
Data[, Yutm = .Y]
Data[, ScientificName = .ScientificName]
Data[, VernName = .VernName]
Data[, Family = .Family]
Data[, Genus = .Genus]
Data[, Species = .Species]
Data[, CommercialSp = .CommercialSp]
Data[, TreeHeight = .TreeHeight]
Data[, TreeHeightUnit = .TreeHeightUnit]
}, env)) # eval(substitute( END
data(ParacouSubsetWide)
Data = ParacouSubsetWide
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
DataInput <- copy(Data) # input data copy
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
eval(substitute( # use of argument values as variables
{
## Wide to long format (detect and reshape)
# Detects arguments with multiple values
# pata = list(a = 2, b = c(9,5,6)) # list
# length(unlist(pata["b"])) # 3
# length(pata$a) # 1
# length(pata$b) # 3
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
ArgsNames <- c("Plot", "SubPlot", "Time", "TreeFieldNum", "IdTree", # arguments names
"LifeStatus", "Size", "POM", "X", "Y", "ScientificName",
"VernName", "Family", "Genus", "Species", "CommercialSp", "TreeHeight")
ColToTranspos_argname <- vector("character") # empty vectors
for (N in 1:length(ArgsNames)) {
if(length(unlist(ColsList[ ArgsNames[[N]] ])) > 1) # arg = multiple values
ColToTranspos_argname <- c(ColToTranspos_argname, ArgsNames[[N]] )
}
# User col names in character (=argument values)
ColToTranspos <- unlist(ColsList[ColToTranspos_argname], use.names = FALSE)
ColToTranspos <- ColToTranspos[!ColToTranspos %in% "none"]
if(length(ColToTranspos_argname) == 1){
ValuesColName <- readline(cat("To which variable do the values in columns '", ColToTranspos,"' correspond?
1: Size\n
2: POM\n
3: TreeHeight\n")) # question to the user
if(ValuesColName == "1") ValuesColName <- "Size"
if(ValuesColName == "2") ValuesColName <- "POM"
if(ValuesColName == "3") ValuesColName <- "TreeHeight"
# Work only with 1 col to create from the wide format columns
Data <- data.table::melt(Data,
measure.vars = ColToTranspos, # cols to rows (arguments pour lesquels un vecteur est renseigné)
variable.name = ColToTranspos_argname, # name of the new column (length=1) that contains the names of the transposed variables
value.name = ValuesColName) # name of the new column that contains the values of the transposed variables
if(ColToTranspos_argname == "Time"){
Time <- ColToTranspos_argname
}else{
stop(cat("To create the cases where 'Time' is not the variable to transpose"))
}
} # ColToTranspos_argname == 1
## Class changing
### if it's a code
# for(u in 1:length(argsUnit)){ # argsUnit: SizeUnit, POMUnit, TreeHeightUnit
#   if(argsUnit[u] == "code"){
#
#   }
# }
### as.character
CharacVar <- c(Plot, SubPlot, TreeFieldNum, IdTree, ScientificName, VernName, Family, Genus, Species) # character variables
CharacVar <- CharacVar[!CharacVar %in% "none"]
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c(Time, Size, PlotArea, X, Y, TreeHeight) # numeric variables
NumVar <- NumVar[!NumVar %in% "none"]
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c(LifeStatus, CommercialSp) # logical variables
LogicVar <- LogicVar[!LogicVar %in% "none"]
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
## Units changing
### Size in cm
if(Size %in% names(Data)){
if (substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi")
Data[, c(Size) := .Size/10] # mm -> cm
if (substr(SizeUnit, 1, 1) == "d")
Data[, c(Size) := .Size*10] # dm -> cm
if (substr(SizeUnit, 1, 1) == "m")
Data[, c(Size) := .Size*100] # m -> cm
}
### TreeHeight in m
if(TreeHeight %in% names(Data)){
if (substr(TreeHeightUnit, 1, 2) == "mm" | substr(TreeHeightUnit, 1, 2) == "mi")
Data[, c(TreeHeight) := .TreeHeight/1000] # mm -> m
if (substr(TreeHeightUnit, 1, 1) == "m")
Data[, c(TreeHeight) := .TreeHeight/100] # cm -> m
if (substr(TreeHeightUnit, 1, 1) == "d")
Data[, c(TreeHeight) := .TreeHeight/10] # dm -> m
}
## Necessary columns creation from the existing
### IdTree (unique along Plot, SubPlot, TreeFieldNum)
# Data[,  idTree := NULL]
if(!IdTree %in% names(Data) & all(c(Plot, SubPlot, TreeFieldNum) %in% names(Data))){
uniq_key <- unique(Data[, c(Plot, SubPlot, TreeFieldNum)])
uniq_key[, IdTree := seq(1, nrow(uniq_key))]
merge(Data, uniq_key)
}
### POM ? (if pom is a code)
### PlotArea (not a column but a value)
if(!PlotArea %in% names(Data) & is.numeric(PlotArea)){
if(length(PlotArea) == 1){ # if PlotArea is a (1) numeric value
Data[,  PlotArea := PlotArea]
}
# if(length(PlotArea) > 1){ # cas à faire : c(1 val par plot)
#   Data[,  PlotArea := PlotArea, by = Plot] # grouped
#   Data[,  PlotArea := PlotArea, by = .(Plot)] # roup rows by values in specified column
#
#   Data[Plot == Plot1,  PlotArea := PlotArea1] # subset
# }
}
### Genus Species (if ScientificName exists) (detect or ask the sep?)
if(!all(c(Genus, Species) %in% names(Data)) & ScientificName %in% names(Data)){ # or c(Genus, Species) == "none"
# Ask the sep
SfcnameSep <- readline(cat(
"What is the separator (., _, , etc) between the genus and the species in '", ScientificName,"'?")) # question to the user
Data[, c("Genus", "Species") := tstrsplit(ScientificName, SfcnameSep, fixed = TRUE)]
}
### ScientificName (if Genus & Species exist)
if(!ScientificName %in% names(Data) & all(c(Genus, Species) %in% names(Data))) # or ScientificName == "none"
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
# Columns renaming Data[, new = old]
Data[, Plot = .Plot]
Data[, SubPlot = .Plot]
Data[, Time = .Plot]
Data[, TreeFieldNum = .TreeFieldNum]
Data[, IdTree = .IdTree]
Data[, LifeStatus = .LifeStatus]
Data[, Size = .Size]
Data[, POM = .POM]
Data[, Plot = .Plot]
Data[, PlotArea = .PlotArea]
Data[, Xutm = .X]
Data[, Yutm = .Y]
Data[, ScientificName = .ScientificName]
Data[, VernName = .VernName]
Data[, Family = .Family]
Data[, Genus = .Genus]
Data[, Species = .Species]
Data[, CommercialSp = .CommercialSp]
Data[, TreeHeight = .TreeHeight]
Data[, TreeHeightUnit = .TreeHeightUnit]
}, env)) # eval(substitute( END
View(Data)
# Columns renaming Data[, new = old]
eval(substitute( # use of argument values as variables
{
Data[, Plot = .Plot]
Data[, SubPlot = .Plot]
Data[, Time = .Plot]
Data[, TreeFieldNum = .TreeFieldNum]
Data[, IdTree = .IdTree]
Data[, LifeStatus = .LifeStatus]
Data[, Size = .Size]
Data[, POM = .POM]
Data[, Plot = .Plot]
Data[, PlotArea = .PlotArea]
Data[, Xutm = .X]
Data[, Yutm = .Y]
Data[, ScientificName = .ScientificName]
Data[, VernName = .VernName]
Data[, Family = .Family]
Data[, Genus = .Genus]
Data[, Species = .Species]
Data[, CommercialSp = .CommercialSp]
Data[, TreeHeight = .TreeHeight]
Data[, TreeHeightUnit = .TreeHeightUnit]
}, env)) # eval(substitute( END
env
setnames(Data, "Yfield", "patate")
Data <- setnames(Data, "Yfield", "patate")
Data <- setnames(Data, "Forest", "patate")
View(Data)
load("C:/Users/Utilisateur/AppData/Local/ProjetsR/TreeData/data/ParacouSubsetWide.rda")
library(TreeData)
library(data.table)
library(TreeData)
library(data.table)
data(ParacouSubsetWide)
Data = ParacouSubsetWide
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = c("2016","2017","2018","2019","2020")
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
DataInput <- copy(Data) # input data copy
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
eval(substitute( # use of argument values as variables
{
## Wide to long format (detect and reshape)
# Detects arguments with multiple values
# pata = list(a = 2, b = c(9,5,6)) # list
# length(unlist(pata["b"])) # 3
# length(pata$a) # 1
# length(pata$b) # 3
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
ArgsNames <- c("Plot", "SubPlot", "Time", "TreeFieldNum", "IdTree", # arguments names
"LifeStatus", "Size", "POM", "X", "Y", "ScientificName",
"VernName", "Family", "Genus", "Species", "CommercialSp", "TreeHeight")
ColToTranspos_argname <- vector("character") # empty vectors
for (N in 1:length(ArgsNames)) {
if(length(unlist(ColsList[ ArgsNames[[N]] ])) > 1) # arg = multiple values
ColToTranspos_argname <- c(ColToTranspos_argname, ArgsNames[[N]] )
}
# User col names in character (=argument values)
ColToTranspos <- unlist(ColsList[ColToTranspos_argname], use.names = FALSE)
ColToTranspos <- ColToTranspos[!ColToTranspos %in% "none"]
if(length(ColToTranspos_argname) == 1){
ValuesColName <- readline(cat("To which variable do the values in columns '", ColToTranspos,"' correspond?
1: Size\n
2: POM\n
3: TreeHeight\n")) # question to the user
if(ValuesColName == "1") ValuesColName <- "Size"
if(ValuesColName == "2") ValuesColName <- "POM"
if(ValuesColName == "3") ValuesColName <- "TreeHeight"
# Work only with 1 col to create from the wide format columns
Data <- data.table::melt(Data,
measure.vars = ColToTranspos, # cols to rows (arguments pour lesquels un vecteur est renseigné)
variable.name = ColToTranspos_argname, # name of the new column (length=1) that contains the names of the transposed variables
value.name = ValuesColName) # name of the new column that contains the values of the transposed variables
if(ColToTranspos_argname == "Time"){
Time <- ColToTranspos_argname
}else{
stop(cat("Create the cases where 'Time' is not the variable to transpose"))
}
} # ColToTranspos_argname == 1
## Class changing
### if it's a code
# for(u in 1:length(argsUnit)){ # argsUnit: SizeUnit, POMUnit, TreeHeightUnit
#   if(argsUnit[u] == "code"){
#
#   }
# }
### as.character
CharacVar <- c(Plot, SubPlot, TreeFieldNum, IdTree, ScientificName, VernName, Family, Genus, Species) # character variables
CharacVar <- CharacVar[!CharacVar %in% "none"]
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c(Time, Size, PlotArea, X, Y, TreeHeight) # numeric variables
NumVar <- NumVar[!NumVar %in% "none"]
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c(LifeStatus, CommercialSp) # logical variables
LogicVar <- LogicVar[!LogicVar %in% "none"]
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
## Units changing
### Size in cm
if(Size %in% names(Data)){
if (substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi")
Data[, c(Size) := .Size/10] # mm -> cm
if (substr(SizeUnit, 1, 1) == "d")
Data[, c(Size) := .Size*10] # dm -> cm
if (substr(SizeUnit, 1, 1) == "m")
Data[, c(Size) := .Size*100] # m -> cm
}
### TreeHeight in m
if(TreeHeight %in% names(Data)){
if (substr(TreeHeightUnit, 1, 2) == "mm" | substr(TreeHeightUnit, 1, 2) == "mi")
Data[, c(TreeHeight) := .TreeHeight/1000] # mm -> m
if (substr(TreeHeightUnit, 1, 1) == "m")
Data[, c(TreeHeight) := .TreeHeight/100] # cm -> m
if (substr(TreeHeightUnit, 1, 1) == "d")
Data[, c(TreeHeight) := .TreeHeight/10] # dm -> m
}
## Necessary columns creation from the existing
### IdTree (unique along Plot, SubPlot, TreeFieldNum)
# Data[,  idTree := NULL]
if(!IdTree %in% names(Data) & all(c(Plot, SubPlot, TreeFieldNum) %in% names(Data))){
uniq_key <- unique(Data[, c(Plot, SubPlot, TreeFieldNum)])
uniq_key[, IdTree := seq(1, nrow(uniq_key))]
merge(Data, uniq_key)
IdTree <- "IdTree"
}
### POM ? (if pom is a code)
### PlotArea (not a column but a value)
if(!PlotArea %in% names(Data) & is.numeric(PlotArea)){
if(length(PlotArea) == 1){ # if PlotArea is a (1) numeric value
Data[,  PlotArea := PlotArea]
PlotArea <- "PlotArea"
}
# if(length(PlotArea) > 1){ # cas à faire : c(1 val par plot)
#   Data[,  PlotArea := PlotArea, by = Plot] # grouped
#   Data[,  PlotArea := PlotArea, by = .(Plot)] # roup rows by values in specified column
#
#   Data[Plot == Plot1,  PlotArea := PlotArea1] # subset
# }
}
### Genus Species (if ScientificName exists) (detect or ask the sep?)
if(!all(c(Genus, Species) %in% names(Data)) & ScientificName %in% names(Data)){ # or c(Genus, Species) == "none"
# Ask the sep
SfcnameSep <- readline(cat(
"What is the separator (., _, , etc) between the genus and the species in '", ScientificName,"'?")) # question to the user
Data[, c("Genus", "Species") := tstrsplit(ScientificName, SfcnameSep, fixed = TRUE)]
Genus <- "Genus"
Species <- "Species"
}
### ScientificName (if Genus & Species exist)
if(!ScientificName %in% names(Data) & all(c(Genus, Species) %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
ScientificName <- "ScientificName"
}
# Columns renaming Data[, new = old]
Data[, Plot := .Plot]
Data[, SubPlot := .Plot]
Data[, Time := .Plot]
Data[, TreeFieldNum = .TreeFieldNum]
Data[, IdTree = .IdTree]
Data[, LifeStatus = .LifeStatus]
Data[, Size = .Size]
Data[, POM = .POM]
Data[, PlotArea = .PlotArea]
Data[, Xutm = .X]
Data[, Yutm = .Y]
Data[, ScientificName = .ScientificName]
Data[, VernName = .VernName]
Data[, Family = .Family]
Data[, Genus = .Genus]
Data[, Species = .Species]
Data[, CommercialSp = .CommercialSp]
Data[, TreeHeight = .TreeHeight]
Data[, TreeHeightUnit = .TreeHeightUnit]
}, env)) # eval(substitute( END
# Columns renaming Data[, new = old]
Data <- setnames(Data, "Plot", Plot)
Data <- setnames(Data, "SubPlot", SubPlot)
SubPlot
Plot
View(Data)
# Columns renaming Data[, new = old]
Data <- setnames(Data, "Plot", Plot)
# Columns renaming Data[, new = old]
Data <- setnames(Data, Plot, "Plot")
Data <- setnames(Data, SubPlot, "SubPlot")
SubPlot
View(Data)
library(TreeData)
library(data.table)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CensusYear", "Time")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "Circ", "DBH")
Data <- setnames(Data, "MeasCode", "POM")
Data <- setnames(Data, "idTree", "IdTree")
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# setnames(Data, "old", "new")
Data[, Plot := NULL]
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CensusYear", "Time")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "Circ", "DBH")
Data <- setnames(Data, "MeasCode", "POM")
Data <- setnames(Data, "idTree", "IdTree")
# ScientificName (if Genus & Species exist)
if(!ScientificName %in% names(Data) & all(c(Genus, Species) %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c(Genus, Species) %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c("Genus", "Species") %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
View(Data)
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
View(Data)
### as.numeric
NumVar <- c("Time", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c("LifeStatus", "CommercialSp") # logical variables
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
View(Data)
library(TreeData)
library(data.table)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# setnames(Data, "old", "new")
Data[, Plot := NULL]
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "Circ", "DBH")
Data <- setnames(Data, "MeasCode", "POM")
Data <- setnames(Data, "idTree", "IdTree")
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c("Genus", "Species") %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c("Time", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c("CensusYear", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c("LifeStatus", "CommercialSp") # logical variables
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
