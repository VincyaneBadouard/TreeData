Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
env
rm(env)
Vars <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, Size, POM, X, Y) # col names (chr)
Vars
Vars <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, Size, POM, X, Y) # col names (chr)
Vars <- Vars[!Vars %in% "none"]
for (v in Vars) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(get(Vars[v])) | get(Vars[v]) == 0, get(Vars[v])]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
View(Data)
View(Data)
MissingVal
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(get(Vars[v])) | get(Vars[v]) == 0, get(Vars[v])]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
View(Data)
MissingVal
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
View(Data)
eval(substitute( # use of argument values as variables
{
Vars <- c(.Plot, .SubPlot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables
{
Vars <- c(.Plot, .SubPlot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
env
View(Data)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = "CensusYear"
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
eval(substitute( # use of argument values as variables
{
Vars <- c(.Plot, .SubPlot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables .SubPlot,
{
Vars <- c(.Plot, .Time, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables .SubPlot, .Time,
{
Vars <- c(.Plot, .TreeFieldNum, .IdTree, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
eval(substitute( # use of argument values as variables .SubPlot, .Time, .IdTree,
{
Vars <- c(.Plot, .TreeFieldNum, .LifeStatus, .Size, .POM, .X, .Y) # col names (chr)
#
# for (v in 1:length(Vars)) {
#
#   if(Vars[v] %in% names(Data)){ # If the column exists
#
#     MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v]]
#
#     if(any(MissingVal)){ # but have NA values
#       Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
#     }
#   }
# }
}, env)) # eval(substitute( END
Vars <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, Size, POM, X, Y) # col names (chr)
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE]
if(any(MissingVal)){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE]
# if(any(MissingVal)){ # but have NA values
#   Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
# }
}
}
MissingVal
any(MissingVal)
nrow(MissingVal) > 0
correspondances <- na.omit(unique(Data[, c(IdTree, Plot, SubPlot, TreeFieldNum), with = FALSE])) # with = FALSE: the column names can be used as variables
correspondances
CorresIDs <- correspondances[, IdTree, with = FALSE]
CorresIDs
identical(CorresIDs, unique(CorresIDs))
CorresIDs
unique(CorresIDs)
library(dplyr)
library(data.table)
library(dtplyr)
library(ggplot2)
N <- 10^6
test <- data.frame(species = sample(LETTERS, N, replace = T),
trait = rnorm(N))
dplyr_fun <- function(data, variable, value){
dplyr::filter(data, {{variable}} == value)
}
dt_fun <- function(data, variable, value){
env <- list(.variable = as.name(variable),
.value = value)
eval(substitute(
{
as.data.table(data)[.variable == .value]
}, env))
}
dtplyr_fun <- function(data, variable, value){
data %>%
lazy_dt() %>%
filter({{variable}} == value)
}
install.packages("dtplyr")
library(dtplyr)
dtplyr_fun <- function(data, variable, value){
data %>%
lazy_dt() %>%
filter({{variable}} == value)
}
microbenchmark::microbenchmark(dplyr_fun(test, species, "A"),
dt_fun(test, "species", "A"),
dtplyr_fun(test, species, "A")) %>%
as.data.frame() %>%
ggplot(aes(expr, time)) +
geom_boxplot() +
coord_flip() +
theme_bw()
ids
CorresIDs
duplicated(CorresIDs)
dtplyr_fun(test, species, "A")
N <- 10^6
test <- data.frame(species = sample(LETTERS, N, replace = T),
trait = rnorm(N))
dtplyr_fun <- function(data, variable, value){
data %>%
lazy_dt() %>%
filter({{variable}} == value)
}
dtplyr_fun(test, species, "A")
library(dtplyr)
dtplyr_fun(test, species, "A")
library(dplyr)
dtplyr_fun(test, species, "A")
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
library(TreeData)
library(data.table)
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 2 # number of error to add for each case
View(Data)
modif <- Data[, .I[sample(.N, nError)]]
Data[, .I[sample(.N, nError)]]
seq_len(nrow(Data))
Data[modif, Circ := NA]
Data[modif] # to check
wrong <- c(0.2, 0.3, 0.569, 0.8)
modif <- Data[, .I[sample(.N, nError)]]
Data[modif, Circ := Circ + sample(wrong,1), by=idTree]
Data[modif] # to check
modif <- Data[, .I[sample(.N, nError)]]
Data[modif, Circ := Circ + sample(wrong,1)]
Data[modif] # to check
modif <- Data[, .I[sample(.N, nError)]]
Data[modif, Circ := Circ + sample(wrong,1)]
Data[modif] # to check
Last_census <- Data[Time == 2020]
Last_census <- Data[CensusYear == 2020]
Previous_census <- Data[CensusYear == 2019]
names(Data)
Previous_census[CodeAlive == 0 & idTree %in% Last_census[CodeAlive == 1, idArbre], idTree]
Previous_census[CodeAlive == 0 & idTree %in% Last_census[CodeAlive == 1, idTree], idTree]
# See if a resurrected tree already exists
MortPrev <- Previous_census[CodeAlive == 0 & idTree %in% Last_census[CodeAlive == 1, idTree], idTree]
MortPrev
Data[idTree %in% MortPrev, sample(idTree,2)]
MortPrev
Last_census[idTree == 101410]
Previous_census[idTree == 101410]
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, CodeAlive := NA]
Data[modif] # to check
modif <- Data[, .I[sample(.N, 1)]]
duplicatedFieldNum <- Data[!(row.names(Data)) %in% modif & # rows != modif
Plot == Data[modif, Plot] & # same plot as modif
SubPlot == Data[modif, SubPlot], # same subplot as modif
sample(TreeFieldNum,1)]
duplicatedFieldNum
modif
Data[TreeFieldNum == duplicatedFieldNum] # to check
idModif <- Data[, sample(idTree, nError)] # ne chercher que dans ceux qui ne sont pas à verifier pour eviter de prendre certains avec un duplicatedID # selectionner 2 idTree à modifier
idModif
idModif
duplicatedID
duplicatedID <- Last_census[!(idTree %in% idModif), sample(idTree, nError)] # 2 idTree != modif
duplicatedID
idModif
duplicatedID
Data[idTree %in% idModif, idTree := duplicatedID] # we duplicate the idTree on the previous selected idTree
idModif <- Last_census[, sample(idTree, nError)] # ne chercher que dans ceux qui ne sont pas à verifier pour eviter de prendre certains avec un duplicatedID # selectionner 2 idTree à modifier
duplicatedID <- Last_census[!(idTree %in% idModif), sample(idTree, nError)] # 2 idTree != modif
Data[idTree %in% idModif, idTree := duplicatedID] # we duplicate the idTree on the previous selected idTree
idModif
Data[idTree %in% idModif]
duplicatedID
idModif <- Last_census[, sample(idTree, nError)] # ne chercher que dans ceux qui ne sont pas à verifier pour eviter de prendre certains avec un duplicatedID # selectionner 2 idTree à modifier
duplicatedID <- Last_census[!(idTree %in% idModif), sample(idTree, 1)] # idTree != modif
Data[idTree %in% idModif, idTree := duplicatedID] # we duplicate the idTree on the previous selected idTree
Data[CensusYear == 2020 & idTree == duplicatedID] # to check
TestData <- Data
usethis::use_data(TestData)
usethis::use_data_raw()
usethis::use_data_raw(TestData)
usethis::use_data_raw("TestData")
usethis::use_data_raw("ParacouSubsetWide")
usethis::use_data_raw("BarroColoradoSubset")
usethis::use_data_raw("ParacouSubset")
devtools::load_all(".")
devtools::load_all(".")
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = "CensusYear"
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
Vars <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, Size, POM, X, Y) # col names (chr)
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
MissingVal <- Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE] # with=F: the column names can be used as variables
if(nrow(MissingVal) > 0){ # but have NA values
Data[MissingVal, Comment := paste0("Missing value in ", Vars[v])] # comments
}
}
}
# Check for missing coordinates
# missing_coor <- Data[is.na(get(X)) | is.na(get(Y))] # transformer en 1 vect
# if(any(missing_coor)){
#
#   Data[missing_coor, Comment := paste0("Missing coordinates: ",X,", ",Y)]
# }
View(Data)
View(Data)
v =3
Vars[v] %in% names(Data)
Vars[v]
is.na(Vars[v])
is.na(Vars[v])
v =6
Vars[v]
is.na(Vars[v])
Vars[v]
Data[is.na(Vars[v]) | Vars[v] == 0, Vars[v], with = FALSE]
Vars[v]
Data[is.na(CodeAlive) | CodeAlive == 0, CodeAlive, with = FALSE]
Data[is.na(CodeAlive) | CodeAlive == 0, CodeAlive]
any(Data[is.na(CodeAlive) | CodeAlive == 0, CodeAlive])
any(Data[is.na(CodeAlive) | CodeAlive == 0, CodeAlive], na.rm = T)
Data[is.na(CodeAlive)]# | CodeAlive == 0, CodeAlive]
Data[is.na(CodeAlive)] | CodeAlive == 0]
Data[is.na(CodeAlive) | CodeAlive == 0]
Data[is.na(CodeAlive), CodeAlive]
Data[is.na(CodeAlive), Comment := paste0("Missing value in ", Vars[v])]
View(Data)
# INPUTS
Data = TestData
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(CodeAlive), Comment := paste0("Missing value in ", Vars[v]), with = FALSE] # comments
}
}
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(CodeAlive), Comment := paste0("Missing value in ", Vars[v]), with = FALSE] # comments
}
}
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(CodeAlive), (Comment) := paste0("Missing value in ", Vars[v]), with = FALSE] # comments
}
}
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(Vars[v]), Comment := paste0("Missing value in ", Vars[v]), with = FALSE] # comments
}
}
v =6
Data[is.na(Vars[v]), Comment := paste0("Missing value in ", Vars[v]), with = FALSE] # comments
Data[is.na(Vars[v]), "Comment" := paste0("Missing value in ", Vars[v]), with = FALSE] # comments
View(Data)
?':='
Data[is.na(Vars[v]), "Comment" := paste0("Missing value in ", Vars[v])] # comments
View(Data)
is.na(Vars[v])
Vars[v]
