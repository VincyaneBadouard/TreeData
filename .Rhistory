if(Size %in% names(Data)){
if (substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi")
Data[, c(Size) := .Size/10] # mm -> cm
if (substr(SizeUnit, 1, 1) == "d")
Data[, c(Size) := .Size*10] # dm -> cm
if (substr(SizeUnit, 1, 1) == "m")
Data[, c(Size) := .Size*100] # m -> cm
}
}, env)) # eval(substitute( END
Data = ParacouSubsetWide
substr(SizeUnit, 1, 1) == "m"
substr(SizeUnit, 1, 1) == "d"
substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi"
View(Data)
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
eval(substitute(
{
if(Size %in% names(Data)){
if (substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi")
Data[, c(Size) := .Size/10] # mm -> cm
if (substr(SizeUnit, 1, 1) == "d")
Data[, c(Size) := .Size*10] # dm -> cm
if (substr(SizeUnit, 1, 1) == "m")
Data[, c(Size) := .Size*100] # m -> cm
}
}, env)) # eval(substitute( END
eval(substitute(
{
uniq_key <- unique(Data[, c(.Plot, .SubPlot, .TreeFieldNum)]) # , with = FALSE
}, env)) # eval(substitute( END
uniq_key
rm(uniq_key)
eval(substitute(
{
uniq_key <- unique(Data[, c(.Plot, .SubPlot, .TreeFieldNum)]) # , with = FALSE
}, env))
uniq_key
rm(uniq_key)
# if(!IdTree %in% names(Data) & c(Plot, SubPlot, TreeFieldNum) %in% names(Data)){
eval(substitute(
{
uniq_key <- unique(Data[, c(.Plot, .SubPlot, .TreeFieldNum)]) # , with = FALSE
}, env)) # eval(substitute( END
uniq_key
uniq_key <- unique(Data[, c(Plot, SubPlot, TreeFieldNum)])
uniq_key
uniq_key <- uniqueN(Data, by = c(Plot, SubPlot, TreeFieldNum)) # , with = FALSE
uniq_key
uniq_key <- unique(Data, by = c(Plot, SubPlot, TreeFieldNum)) # , with = FALSE
uniq_key
View(uniq_key)
unique(Data[, c(Plot, SubPlot, TreeFieldNum))
uniq_key <- unique(Data, by = c(Plot, SubPlot, TreeFieldNum)) # , with = FALSE
# }, env)) # eval(substitute( END
uniq_key[, IdTree := seq(1, nrow(uniq_key))]
merge(Data, uniq_key)
# }
### POM ? (if pom is a code)
### PlotArea (not a column but a value)
if(!PlotArea %in% names(Data) & is.numeric(PlotArea)){
if(is.numeric(PlotArea)){ # if PlotArea is a (1) (numeric value) (cas à faire : 1 val par plot)
Data[,  PlotArea := PlotArea]
}
}
### Genus Species (if ScientificName exists) (how to know the sep?)
Data[, c("Genus", "Species") := tstrsplit(ScientificName, ".", fixed = TRUE)]
### ScientificName (if Genus & Species exist)
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
# }, env)) # eval(substitute( END
# Return in data.frame
setDF(Data)
return(Data)
}
unique(Data[, c(Plot, SubPlot, TreeFieldNum)])
uniq_key
PlotArea
!PlotArea %in% names(Data) & is.numeric(PlotArea)
PlotArea = 4
!PlotArea %in% names(Data) & is.numeric(PlotArea)
length(PlotArea)
length(PlotArea) == 1
Data[,  patate := PlotArea]
PlotArea
class(Data)
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Data[,  patate := PlotArea]
Data[,  patate := 4]
View(Data)
eval(substitute(
{
### ScientificName (if Genus & Species exist)
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
}, env)) # eval(substitute( END
View(Data)
Genus
Species
Data = ParacouSubsetWide
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
eval(substitute(
{
### ScientificName (if Genus & Species exist)
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
}, env)) # eval(substitute( END
View(Data)
Data = ParacouSubsetWide
data(ParacouSubsetWide)
Data = ParacouSubsetWide
View(Data)
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
View(Data)
eval(substitute(
{
### ScientificName (if Genus & Species exist)
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
}, env)) # eval(substitute( END
View(Data)
library(TreeData)
data(ParacouSubsetWide)
Required_Format <- RequiredFormat(
ParacouSubsetWide,
Plot = "SubPlot",
SubPlot = "SubSubPlot",
Time = c("2016","2017","2018","2019","2020"),
TreeFieldNum = "TreeFieldNum",
IdTree = "idTree",
LifeStatus = "CodeAlive",
Size = "Circ",
SizeUnit = "m",
POM = "MeasCode",
POMUnit = "code",
PlotArea = "PlotArea",
X = "Xutm",
Y = "Yutm",
ScientificName = "none",
VernName = "VernName",
Family = "Family",
Genus = "Genus",
Species = "Species",
CommercialSp = "CommercialSp",
TreeHeight = "none",
TreeHeightUnit = "none")
View(Required_Format)
data(ParacouSubsetWide)
Data = ParacouSubsetWide
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = c("2016","2017","2018","2019","2020")
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
args <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, # arguments VALUES
Size, SizeUnit, POM, POMUnit, X, Y,
ScientificName, VernName, Family, Genus, Species, CommercialSp,
TreeHeight, TreeHeightUnit)
# a value of NULL deletes the corresponding item of the list.
argsCol <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, # columns names arguments
Size, POM, X, Y, ScientificName, VernName, Family, Genus,
Species, CommercialSp, TreeHeight)
argsUnit <-  c(SizeUnit, POMUnit, TreeHeightUnit) # units arguments
## Argument class
if (!inherits(Data, "data.frame"))
stop("Data must be a data.frame")
if(!any(is.character(PlotArea) || is.numeric(PlotArea)))
stop(cat(PlotArea, "must be in character or numeric"))
if(is.character(PlotArea))
argsCol <- c(argsCol, PlotArea) # PlotArea is a column name
for(i in 1:length(args)) # all args
if(!inherits(args[i], "character"))
stop(paste0(args[i], "must be in character"))
## The column name exists
for(i in 1:length(argsCol))
if(!argsCol[i] %in% names(Data) & argsCol[i] != "none")
stop(paste0(argsCol[i]," is not a column name of your dataset"))
# if the variable exists but the unit is not indicated
if(SizeUnit == "none" & Size != "none")
SizeUnit <- readline(cat("In what unit is your variable '", Size,"'?")) # question to the user
if(POMUnit == "none" & POM != "none")
POMUnit <- readline(cat("In what unit is your variable '", POM,"'?")) # question to the user. "code" is a possible answer
if(TreeHeightUnit == "none" & TreeHeight != "none")
TreeHeightUnit <- readline(cat("In what unit is your variable '", TreeHeight,"'?")) # question to the user
if(length(argsUnit) > 0){
for(i in 1:length(argsUnit))
if(!argsUnit[i] %in% c("none", "code", "mm", "millimetre", "millimeter", "milimetro", "milimetrica",
"cm", "centimetre", "centimeter", "centimetro",
"dm", "decimetre", "decimeter", "decimetro",
"m", "metre", "meter", "metro")
)
stop("Please indicate units with 'mm' for millimetres, 'cm' for
centimetres, 'dm' for decimetres and 'm' for metres")
}
View(Data)
# Environment
# list with new names for the object in arguments (to avoid conflict and work with user variables names)
env <- lapply(list(.Plot = Plot,
.SubPlot = SubPlot,
.Time = Time,    # if it's a vector as.name keeps only the first column name
.TreeFieldNum = TreeFieldNum,
.IdTree = IdTree,
.LifeStatus = LifeStatus,
.Size = Size,
.POM = POM,
.PlotArea = PlotArea,
.X = X,
.Y = Y,
.ScientificName = ScientificName,
.VernName = VernName,
.Family = Family,
.Genus = Genus,
.Species = Species,
.CommercialSp = CommercialSp,
.TreeHeight = TreeHeight
), as.name) # refer to R object by their name. Doesn't work if the value is NULL
DataInput <- copy(Data) # input data copy
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
View(Data)
CharacVar <- c(Plot, SubPlot, TreeFieldNum, IdTree, ScientificName, VernName, Family, Genus, Species) # character variables
CharacVar <- CharacVar[!CharacVar %in% "none"]
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
View(Data)
View(Data)
NumVar <- c(Time, Size, PlotArea, X, Y, TreeHeight) # numeric variables
NumVar <- NumVar[!NumVar %in% "none"]
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar]
View(Data)
LogicVar <- c(LifeStatus, CommercialSp) # logical variables
LogicVar <- LogicVar[!LogicVar %in% "none"]
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar]
View(Data)
if(Size %in% names(Data)){
if (substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi")
Data[, c(Size) := .Size/10] # mm -> cm
if (substr(SizeUnit, 1, 1) == "d")
Data[, c(Size) := .Size*10] # dm -> cm
if (substr(SizeUnit, 1, 1) == "m")
Data[, c(Size) := .Size*100] # m -> cm
}
eval(substitute(
{
if(Size %in% names(Data)){
if (substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi")
Data[, c(Size) := .Size/10] # mm -> cm
if (substr(SizeUnit, 1, 1) == "d")
Data[, c(Size) := .Size*10] # dm -> cm
if (substr(SizeUnit, 1, 1) == "m")
Data[, c(Size) := .Size*100] # m -> cm
}
### TreeHeight in m
if(TreeHeight %in% names(Data)){
if (substr(TreeHeightUnit, 1, 2) == "mm" | substr(TreeHeightUnit, 1, 2) == "mi")
Data[, c(TreeHeight) := .TreeHeight/1000] # mm -> m
if (substr(TreeHeightUnit, 1, 1) == "m")
Data[, c(TreeHeight) := .TreeHeight/100] # cm -> m
if (substr(TreeHeightUnit, 1, 1) == "d")
Data[, c(TreeHeight) := .TreeHeight/10] # dm -> m
}
}, env)) # eval(substitute( END
View(Data)
if(!IdTree %in% names(Data) & c(Plot, SubPlot, TreeFieldNum) %in% names(Data)){
uniq_key <- unique(Data[, c(Plot, SubPlot, TreeFieldNum)])
uniq_key[, IdTree := seq(1, nrow(uniq_key))]
merge(Data, uniq_key)
}
c(Plot, SubPlot, TreeFieldNum) %in% names(Data)
if(!IdTree %in% names(Data) & all(c(Plot, SubPlot, TreeFieldNum) %in% names(Data))){
uniq_key <- unique(Data[, c(Plot, SubPlot, TreeFieldNum)])
uniq_key[, IdTree := seq(1, nrow(uniq_key))]
merge(Data, uniq_key)
}
View(Data)
### PlotArea (not a column but a value)
if(!PlotArea %in% names(Data) & is.numeric(PlotArea)){
if(length(PlotArea) == 1){ # if PlotArea is a (1) numeric value
Data[,  PlotArea := PlotArea]
}
# if(length(PlotArea) > 1){ # cas à faire : c(1 val par plot)
#   Data[,  PlotArea := PlotArea, by = Plot] # grouped
#   Data[,  PlotArea := PlotArea, by = .(Plot)] # roup rows by values in specified column
#
#   Data[Plot == Plot1,  PlotArea := PlotArea1] # subset
# }
}
View(Data)
ScientificName
!ScientificName %in% names(Data) & all(c(Genus, Species) %in% names(Data))
c(Genus, Species) %in% names(Data)
!all(c(Genus, Species) %in% names(Data))
ScientificName %in% names(Data)
!all(c(Genus, Species) %in% names(Data)) & ScientificName %in% names(Data)
c(Genus, Species) == "none"
library(TreeData)
library(TreeData)
data(ParacouSubsetWide)
Required_Format <- RequiredFormat(
ParacouSubsetWide,
Plot = "SubPlot",
SubPlot = "SubSubPlot",
Time = c("2016","2017","2018","2019","2020"),
TreeFieldNum = "TreeFieldNum",
IdTree = "idTree",
LifeStatus = "CodeAlive",
Size = "Circ",
SizeUnit = "m",
POM = "MeasCode",
POMUnit = "code",
PlotArea = "PlotArea",
X = "Xutm",
Y = "Yutm",
ScientificName = "none",
VernName = "VernName",
Family = "Family",
Genus = "Genus",
Species = "Species",
CommercialSp = "CommercialSp",
TreeHeight = "none",
TreeHeightUnit = "none")
View(Required_Format)
data(ParacouSubsetWide)
Data = ParacouSubsetWide
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = c("2016","2017","2018","2019","2020")
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
argsCol <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, # columns names arguments
Size, POM, X, Y, ScientificName, VernName, Family, Genus,
Species, CommercialSp, TreeHeight)
argsCol
str(Time)
typeof(Time)
c(a = 2, b = c(1,2,3))
pata = c(a = 2, b = c(1,2,3))
pata$b
pata[b]
pata[a]
pata[[a]]
str(pata)
a
pata["a"]
pata["b"]
names(pata)
pata = c(a = 2, b = c(9,5,6))
names(pata)
pata
list(a = 2, b = c(9,5,6))
names(pata)
pata$b
pata[b]
pata
pata = list(a = 2, b = c(9,5,6)) # list
pata[a]
pata
pata$a
length(pata$a)
length(pata$b)
list(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, # arguments VALUES
Size, SizeUnit, POM, POMUnit, X, Y,
ScientificName, VernName, Family, Genus, Species, CommercialSp,
TreeHeight, TreeHeightUnit)
list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, SizeUnit=SizeUnit, POM=POM,
POMUnit=POMUnit, X=X, Y=Y, ScientificName=ScientificName,
VernName=VernName, Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp,TreeHeight=TreeHeight,
TreeHeightUnit=TreeHeightUnit)
for(i in 1:length(args)) # all args
if(!inherits(args[i], "character"))
stop(paste0(args[i], "must be in character"))
for(i in 1:length(args)) # all args
if(!inherits(args$i, "character"))
stop(paste0(args$i, "must be in character"))
i = 2
args$i
args <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, SizeUnit=SizeUnit, POM=POM,
POMUnit=POMUnit, X=X, Y=Y, ScientificName=ScientificName,
VernName=VernName, Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp,TreeHeight=TreeHeight,
TreeHeightUnit=TreeHeightUnit)
for(i in 1:length(args)) # all args
if(!inherits(args$i, "character"))
stop(paste0(args$i, "must be in character"))
args$i
args
for(i in args) # all args
if(!inherits(args$i, "character"))
stop(paste0(args$i, "must be in character"))
args$i
names(args)
for(i in names(args)) # all args
if(!inherits(args$i, "character"))
stop(paste0(args$i, "must be in character"))
unquote(names(args))
length(ColsList)
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
data(ParacouSubsetWide)
Data = ParacouSubsetWide
library(TreeData)
data(ParacouSubsetWide)
Data = ParacouSubsetWide
Plot = "SubPlot"
SubPlot = "SubSubPlot"
Time = c("2016","2017","2018","2019","2020")
TreeFieldNum = "TreeFieldNum"
IdTree = "idTree"
LifeStatus = "CodeAlive"
Size = "Circ"
SizeUnit = "m"
POM = "MeasCode"
POMUnit = "code" # NULL
PlotArea = "PlotArea"
X = "Xutm"
Y = "Yutm"
ScientificName = "none" # NULL
VernName = "none" # NULL
Family = "Family"
Genus = "Genus"
Species = "Species"
CommercialSp = "CommercialSp"
TreeHeight = "none" # NULL
TreeHeightUnit = "none" # NULL
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
length(ColsList)
lapply(list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight), as.name)
lapply(list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight), as.name)
pata = list(a = 2, b = c(9,5,6)) # list
pata["a"]
pata["b"]
length(pata["b"])
pata["b"]
length(pata["b"])
length(pata$b) # 3
pata["b"]
t = pata["b"]
length(unlist(pata["b"]))
args <- c(Plot, SubPlot, Time, TreeFieldNum, IdTree, LifeStatus, # arguments VALUES
Size, SizeUnit, POM, POMUnit, X, Y,
ScientificName, VernName, Family, Genus, Species, CommercialSp,
TreeHeight, TreeHeightUnit)
as.name(args)
ArgsNames[1]
ArgsNames <- c("Plot", "SubPlot", "Time", "TreeFieldNum", "IdTree", # columns names arguments
"LifeStatus", "Size", "POM", "X", "Y", "ScientificName",
"VernName", "Family", "Genus", "Species", "CommercialSp", "TreeHeight")
ArgsNames[1]
ColToTranspos <- FixCols <- vector() # empty vectors
for (N in ArgsNames) {
if(length(unlist(ColsList[ArgsNames[N]])) == 1)
FixCols <- c(FixCols, ArgsNames[N]) # arg = 1 value
if(length(unlist(ColsList[ArgsNames[N]])) > 1)
ColToTranspos <- c(FixCols, ArgsNames[N]) # arg = a vector of values
}
FixCols
ColToTranspos
library(TreeData)
