VBS_test <- CompareSim(Param = Param ,
priors = priors, D2fill = D2fill, DAsso = DAsso)
ResL <- VBS_test@results[[1]] # here we get all the simulation of scenario 1
ResL
# TestData : if the tree was used for test subset
# ValidAsso : if the botanical association was correct
# Calculate the percentage of good association for each tested tree, for this scenario:
Res <- rbindlist(ResL) # combine them in a single data.table
PropGood <- Res[TestData==TRUE & ValidAsso==TRUE,
list(propOK=.N/length(ResL)),
by=idTree]
head(PropGood)
ResL
PropGood
head(PropGood)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
View(Data)
## code to prepare `StandardData` dataset goes here
#### Packages libraries ####
library(TreeData)
library(data.table)
#### Import data ####
data("ParacouSubset") # import data
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
#### Delete some columns ####
# Data[, CircCorr := NULL] # je les garde pour l'instant pour comparer avec mes corrections
# Data[, CorrCode := NULL]
#### Columns renaming ####
# setnames(Data, "old", "new")
Data <- setnames(Data, "Forest", "Site")
Data[, Plot := NULL]
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "idTree", "IdTree")
#### Circ to DBH ####
if (!"DBH" %in% names(Data) & "Circ" %in% names(Data)) {
Data[, DBH := Circ/pi]
}
#### Necessary columns creation from the existing ####
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c("Genus", "Species") %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
#### Class changing ####
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c("CensusYear", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c("LifeStatus", "CommercialSp") # logical variables
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
#### Save this test data in the package ####
StandardData <- Data
usethis::use_data(StandardData, overwrite = TRUE)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
View(Data)
## code to prepare `TestData` dataset goes here
#### Packages libraries ####
library(TreeData)
library(data.table)
#### Import data ####
data("StandardData") # import data
Data = StandardData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 1 # number of error to add for each case
#### Tree size = 0 ####
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, DBH := 0]
# Data[modif] # to check
#### Missing coordinates ####
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Xutm := NA]
Data[modif, Yutm := NA]
# Data[modif] # to check
#### Other missing values ####
Vars <- c("PlotArea", "Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree",
"DBH", "LifeStatus", "MeasCode", "Family", "Genus", "Species",
"VernName", "ScientificName", "CommercialSp")
modifs <- c()
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Vars[v] := NA]
modifs <- c(modifs, modif)
}
# Data[modifs] # to check
#### Size with bad precision (pas .0 ou .5) ####
wrong <- c(0.2, 0.3, 0.569, 0.8)
modif <- Data[, .I[sample(.N, nError)]]
Data[modif, DBH := DBH + sample(wrong,1)]
# Data[modif] # to check
#### Resurrected tree ####
Last_census <- Data[CensusYear == 2020]
Previous_census <- Data[CensusYear == 2019]
# See if a resurrected tree already exists
MortPrev <- Previous_census[LifeStatus == 0 & IdTree %in% Last_census[LifeStatus == 1, IdTree], IdTree]
# dead in 2019, alive in 2020
Previous_census[IdTree == 101410] # dead
Last_census[IdTree == 101410] # alive
#### Duplicated TreeFieldNum in plot-subplot association ####
modif <- Data[, .I[sample(.N, 1)]] # 1 row to change
duplicatedFieldNum <- Data[!(row.names(Data)) %in% modif & # all rows != modif
Plot == Data[modif, Plot] & # same plot as modif
SubPlot == Data[modif, SubPlot], # same subplot as modif
sample(TreeFieldNum,1)] # 1 TreeFieldNum to duplicate
Data[modif, TreeFieldNum := duplicatedFieldNum] # on the row to modif, we duplicate the TreeFieldNum
# Data[TreeFieldNum == duplicatedFieldNum] # to check
#### Duplicated IdTree in a census ####
idModif <- Last_census[, sample(IdTree, nError)] # ne chercher que dans ceux qui ne sont pas à verifier pour eviter de prendre certains avec un duplicatedID # selectionner 2 IdTree à modifier
duplicatedID <- Last_census[!(IdTree %in% idModif), sample(IdTree, 1)] # IdTree != modif
Data[IdTree %in% idModif, IdTree := duplicatedID] # we duplicate the IdTree on the previous selected IdTree
Data[CensusYear == 2020 & IdTree == duplicatedID] # to check
#### Unseen tree but alive tree after ####
#### Abnomal growth ####
#### Abnomal recruit ####
#### Save this test data in the package ####
TestData <- Data
usethis::use_data(TestData, overwrite = TRUE)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
View(Data)
View(Data)
# Create "PlotSubNum" = "Site/CensusYear/Plot/SubPlot/TreeFieldNum/IdTree"
Data[, PlotSubNum := paste(Site, CensusYear, Plot, SubPlot, TreeFieldNum, IdTree, sep = "/")]
# y = 2019
# p=1
# c= 3
duplicated_num <- num <- vector("character")
# if any duplicats in this col
if(anyDuplicated(Data$PlotSubNum) != 0) {
# For each site
for (s in unique(na.omit(Data$Site))) {
# For each census
for (y in unique(na.omit(Data$CensusYear))) {
# For each plot
for (p in unique(na.omit(Data$Plot))) {
# For each SubPlot in this plot
for (c in unique(na.omit(Data[Data$Plot==p, "SubPlot"]))) {
# For each TreeFieldNum in this SubPlot
for (f in unique(na.omit(Data[Data$SubPlot==c, "TreeFieldNum"]))) {
num <- Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c
& Data$TreeFieldNum == f
,]$IdTree # all the IdTree for each P-SubP-TFN combination
# if there are several IdTree per Plot-SubPlot-TreeFieldNum combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c
& Data$TreeFieldNum == f
& Data$IdTree %in% duplicated_num,
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
} # end TreeFieldNum loop
} # end subplot loop
} # end plot loop
} # end year loop
} # end site loop
}
Data[TreeFieldNum == duplicated_num] # to check (1 duplicate)
Data[IdTree == duplicated_num] # to check (1 duplicate)
View(Data)
anyDuplicated(Data$PlotSubNum)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# Create "PlotSubNum" = "Site/CensusYear/Plot/SubPlot/TreeFieldNum/IdTree"
Data[, PlotSubNum := paste(Site, CensusYear, Plot, SubPlot, TreeFieldNum, IdTree, sep = "/")]
# y = 2019
# p=1
# c= 3
duplicated_num <- num <- vector("character")
(anyDuplicated(Data$PlotSubNum)
anyDuplicated(Data$PlotSubNum)
anyDuplicated(Data$PlotSubNum)
# Check of the unique association of the IdTree with Plot-SubPlot-TreeFieldNum
# For each site
for (s in unique(na.omit(Data$Site))) {
# For each census
for (y in unique(na.omit(Data$CensusYear))) {
correspondances <- unique(Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)])
CorresIDs <- correspondances[, .(IdTree)] # all the possible idtree's
length(CorresIDs)
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
Data[duplicated(CorresIDs),
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
} # end year loop
} # end site loop
# Check of the unique association of the IdTree with Plot-SubPlot-TreeFieldNum
# For each site
for (s in unique(na.omit(Data$Site))) {
# For each census
for (y in unique(na.omit(Data$CensusYear))) {
correspondances <- unique(
Data[Data$Site == s & Data$CensusYear == y, .(IdTree, Plot, SubPlot, TreeFieldNum)])
CorresIDs <- correspondances[, .(IdTree)] # all the possible idtree's
length(CorresIDs)
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)])
Data[Data$Site == s & Data$CensusYear == y &
Data$IdTree %in% duplicated_ID,
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
} # end year loop
} # end site loop
Data[duplicated(CorresIDs)== TRUE]
duplicated_ID <- CorresIDs <- vector("character")
# Check of the unique association of the IdTree with Plot-SubPlot-TreeFieldNum
duplicated_ID <- CorresIDs <- vector("character")
# For each site
for (s in unique(na.omit(Data$Site))) {
# For each census
for (y in unique(na.omit(Data$CensusYear))) {
correspondances <- unique(
Data[Data$Site == s & Data$CensusYear == y, .(IdTree, Plot, SubPlot, TreeFieldNum)])
CorresIDs <- correspondances[, .(IdTree)] # all the possible idtree's
length(CorresIDs)
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)])
Data[Data$Site == s & Data$CensusYear == y &
Data$IdTree %in% duplicated_ID,
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
} # end year loop
} # end site loop
Data[IdTree == duplicated_ID] # to check (1 duplicate)
# Data[duplicated(CorresIDs)== TRUE]
# Data[!duplicated(CorresIDs$IdTree)]
View(correspondances)
Data[Data$Site == s & Data$CensusYear == y, .(IdTree, Plot, SubPlot, TreeFieldNum)]
unique(
Data[Data$Site == s & Data$CensusYear == y, .(IdTree, Plot, SubPlot, TreeFieldNum)]
)
!identical(CorresIDs, unique(CorresIDs))
View(CorresIDs)
unique(CorresIDs)
duplicated_ID
CorresIDs[duplicated(CorresIDs)]
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
duplicated_ID <- CorresIDs <- vector("character")
# For each site
# for (s in unique(na.omit(Data$Site))) {
#   # For each census
#   for (y in unique(na.omit(Data$CensusYear))) {
correspondances <- unique(
Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)] # Data$Site == s & Data$CensusYear == y
)
CorresIDs <- correspondances[, .(IdTree)] # all the Idtree's having a unique P-SubP-TreeFieldNum combination
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)]) # identify the Idtree(s) having several P-SubP-TreeFieldNum combinations
Data[Data$IdTree %in% duplicated_ID, # Data$Site == s & Data$CensusYear == y &
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
#   } # end year loop
# } # end site loop
Data[IdTree == duplicated_ID] # to check (1 duplicate)
Data[IdTree == duplicated_ID] # to check (1 duplicate)
duplicated_ID
View(correspondances)
na.omit(correspondances)
correspondances <- na.omit(unique(
Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)] # Data$Site == s & Data$CensusYear == y
))
CorresIDs <- correspondances[, .(IdTree)] # all the Idtree's having a unique P-SubP-TreeFieldNum combination
!identical(CorresIDs, unique(CorresIDs))
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)]) # identify the Idtree(s) having several P-SubP-TreeFieldNum combinations
Data[Data$IdTree %in% duplicated_ID, # Data$Site == s & Data$CensusYear == y &
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
Data[IdTree == duplicated_ID] # to check (1 duplicate)
duplicated_ID
duplicated_ID
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)]) # identify the Idtree(s) having several P-SubP-TreeFieldNum combinations
duplicated_ID
Data$IdTree %in% duplicated_ID
Data[Data$IdTree %in% duplicated_ID, # Data$Site == s & Data$CensusYear == y &
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
View(Data)
Data[Data$IdTree %in% duplicated_ID] # to check (1 duplicate)
duplicated_ID <- CorresIDs <- vector("character")
correspondances <- na.omit(unique(
Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)] # Data$Site == s & Data$CensusYear == y
))
CorresIDs <- correspondances[, .(IdTree)] # all the Idtree's having a unique P-SubP-TreeFieldNum combination
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)]) # identify the Idtree(s) having several P-SubP-TreeFieldNum combinations
Data[Data$IdTree %in% duplicated_ID, # Data$Site == s & Data$CensusYear == y &
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
Data[IdTree == duplicated_ID] # to check (1 duplicate)
as.vector(duplicated_ID)
any(Data$IdTree %in% duplicated_ID)
Data[IdTree %in% duplicated_ID] # to check (1 duplicate)
duplicated_ID
CorresIDs <- correspondances[, IdTree] # .(IdTree) all the Idtree's having a unique P-SubP-TreeFieldNum combination
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)]) # identify the Idtree(s) having several P-SubP-TreeFieldNum combinations
duplicated_ID
Data[IdTree %in% duplicated_ID] # to check (1 duplicate)
Data[Data$IdTree %in% duplicated_ID, # Data$Site == s & Data$CensusYear == y &
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
Data[IdTree %in% duplicated_ID] # to check (1 duplicate)
View(correspondances)
duplicated_ID
duplicated_ID <- CorresIDs <- vector("character")
# For each site
for (s in unique(na.omit(Data$Site))) {
correspondances <- na.omit(unique(
Data[Data$Site == s, .(IdTree, Plot, SubPlot, TreeFieldNum)] # & Data$CensusYear == y
))
CorresIDs <- correspondances[, IdTree] # .(IdTree) all the Idtree's having a unique P-SubP-TreeFieldNum combination
if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)]) # identify the Idtree(s) having several P-SubP-TreeFieldNum combinations
Data[Data$Site == s & Data$IdTree %in% duplicated_ID,
Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
}
} # end site loop
Data[IdTree %in% duplicated_ID] # to check (1 duplicate)
Data[IdTree %in% duplicated_ID, .(IdTree, Plot, SubPlot, TreeFieldNum, CensusYear)] # to check (1 duplicate)
unique(Data[IdTree %in% duplicated_ID, .(IdTree, Plot, SubPlot, TreeFieldNum, CensusYear)]) # to check
unique(Data[IdTree %in% duplicated_ID, .(IdTree, Plot, SubPlot, TreeFieldNum)]) # to check
unique(Data[Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(IdTree, Plot, SubPlot, TreeFieldNum)]) # to check
unique(Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(IdTree, Plot, SubPlot, TreeFieldNum)]) # to check
unique(Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(arrange(IdTree), Plot, SubPlot, TreeFieldNum)]) # to check
unique(Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(arrange(IdTree), Plot, SubPlot, TreeFieldNum)]) # to check
unique(Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(IdTree := arrange(IdTree), Plot, SubPlot, TreeFieldNum)]) # to check
unique(Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(IdTree, Plot, SubPlot, TreeFieldNum)]) # to check
Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(IdTree, Plot, SubPlot, TreeFieldNum)]
unique(Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
.(IdTree, Plot, SubPlot, TreeFieldNum)]) # to check
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# Create "PlotSubNum" = "Site/CensusYear/Plot/SubPlot/TreeFieldNum"
Data[, PlotSubNum := paste(Site, CensusYear, Plot, SubPlot, TreeFieldNum, sep = "/")]
# y = 2019
# p=1
# c= 3
duplicated_num <- num <- vector("character")
# if any duplicats in this col
if(anyDuplicated(Data$PlotSubNum) != 0) {
# For each site
for (s in unique(na.omit(Data$Site))) {
# For each census
for (y in unique(na.omit(Data$CensusYear))) {
# For each plot
for (p in unique(na.omit(Data$Plot))) {
# For each SubPlot in this plot
for (c in unique(na.omit(Data[Data$Plot==p, "SubPlot"]))) {
num <- Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c
& Data$TreeFieldNum %in% duplicated_num,
Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
}
} # end subplot loop
} # end plot loop
} # end year loop
} # end site loop
}
Data[TreeFieldNum == duplicated_num] # to check (1 duplicate)
anyDuplicated(num)
num
anyDuplicated(Data$PlotSubNum)
num <- Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
num
anyDuplicated(num)
length(unique(num))
duplicated_num <- unique(num[duplicated(num)])
library(TreeData)
library(TreeData)
library(data.table)
knitr::opts_chunk$set(echo = TRUE)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# Create "PlotSubNum" = "Site/CensusYear/Plot/SubPlot/TreeFieldNum"
Data[, PlotSubNum := paste(Site, CensusYear, Plot, SubPlot, TreeFieldNum, sep = "/")]
# y = 2019
# p=1
# c= 3
duplicated_num <- num <- vector("character")
# if any duplicats in this col
if(anyDuplicated(Data$PlotSubNum) != 0) {
# For each site
for (s in unique(na.omit(Data$Site))) {
# For each census
for (y in unique(na.omit(Data$CensusYear))) {
# For each plot
for (p in unique(na.omit(Data$Plot))) {
# For each SubPlot in this plot
for (c in unique(na.omit(Data[Data$Plot==p, "SubPlot"]))) {
num <- Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c
& Data$TreeFieldNum %in% duplicated_num,
Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
}
} # end subplot loop
} # end plot loop
} # end year loop
} # end site loop
}
Data[TreeFieldNum == duplicated_num] # to check (1 duplicate)
# y = 2019
# p=1
# c= 3
duplicated_num <- num <- vector("character")
# if any duplicats in this col
if(anyDuplicated(Data$PlotSubNum) != 0) {
# For each site
for (s in unique(na.omit(Data$Site))) {
# For each census
for (y in unique(na.omit(Data$CensusYear))) {
# For each plot
for (p in unique(na.omit(Data$Plot))) {
# For each SubPlot in this plot
for (c in unique(na.omit(Data[Data$Plot==p, "SubPlot"]))) {
num <- Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
# if there are several TreeFieldNum per Plot-SubPlot combination
if(anyDuplicated(num) != 0){
duplicated_num <- unique(num[duplicated(num)])
Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c
& Data$TreeFieldNum %in% duplicated_num,
Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
}
} # end subplot loop
} # end plot loop
} # end year loop
} # end site loop
}
num
y = 2019
p=1
c= 3
num <- Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
anyDuplicated(num)
c= 4
num <- Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
anyDuplicated(num)
duplicated_num <- unique(num[duplicated(num)])
Data[Data$Site == s & Data$CensusYear == y
& Data$Plot == p & Data$SubPlot == c
& Data$TreeFieldNum %in% duplicated_num,
Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
Data[TreeFieldNum == duplicated_num] # to check (1 duplicate)
Data[TreeFieldNum == duplicated_num.(Plot, SubPlot, TreeFieldNum)] # to check (1 duplicate)
Data[TreeFieldNum == duplicated_num,.(Plot, SubPlot, TreeFieldNum)] # to check (1 duplicate)
library(TreeData)
devtools::load_all(".")
