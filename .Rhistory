setDT(Data) # with "set" "<-" is not necessary
eval(substitute( # use of argument values as variables
{
## Wide to long format (detect and reshape)
# Detects arguments with multiple values
# pata = list(a = 2, b = c(9,5,6)) # list
# length(unlist(pata["b"])) # 3
# length(pata$a) # 1
# length(pata$b) # 3
ColsList <- list(Plot=Plot, SubPlot=SubPlot, Time=Time, # arguments names and values
TreeFieldNum=TreeFieldNum, IdTree=IdTree,
LifeStatus=LifeStatus, Size=Size, POM=POM,
X=X, Y=Y, ScientificName=ScientificName, VernName=VernName,
Family=Family, Genus=Genus, Species=Species,
CommercialSp=CommercialSp, TreeHeight=TreeHeight)
ArgsNames <- c("Plot", "SubPlot", "Time", "TreeFieldNum", "IdTree", # arguments names
"LifeStatus", "Size", "POM", "X", "Y", "ScientificName",
"VernName", "Family", "Genus", "Species", "CommercialSp", "TreeHeight")
ColToTranspos_argname <- vector("character") # empty vectors
for (N in 1:length(ArgsNames)) {
if(length(unlist(ColsList[ ArgsNames[[N]] ])) > 1) # arg = multiple values
ColToTranspos_argname <- c(ColToTranspos_argname, ArgsNames[[N]] )
}
# User col names in character (=argument values)
ColToTranspos <- unlist(ColsList[ColToTranspos_argname], use.names = FALSE)
ColToTranspos <- ColToTranspos[!ColToTranspos %in% "none"]
if(length(ColToTranspos_argname) == 1){
ValuesColName <- readline(cat("To which variable do the values in columns '", ColToTranspos,"' correspond?
1: Size\n
2: POM\n
3: TreeHeight\n")) # question to the user
if(ValuesColName == "1") ValuesColName <- "Size"
if(ValuesColName == "2") ValuesColName <- "POM"
if(ValuesColName == "3") ValuesColName <- "TreeHeight"
# Work only with 1 col to create from the wide format columns
Data <- data.table::melt(Data,
measure.vars = ColToTranspos, # cols to rows (arguments pour lesquels un vecteur est renseigné)
variable.name = ColToTranspos_argname, # name of the new column (length=1) that contains the names of the transposed variables
value.name = ValuesColName) # name of the new column that contains the values of the transposed variables
if(ColToTranspos_argname == "Time"){
Time <- ColToTranspos_argname
}else{
stop(cat("Create the cases where 'Time' is not the variable to transpose"))
}
} # ColToTranspos_argname == 1
## Class changing
### if it's a code
# for(u in 1:length(argsUnit)){ # argsUnit: SizeUnit, POMUnit, TreeHeightUnit
#   if(argsUnit[u] == "code"){
#
#   }
# }
### as.character
CharacVar <- c(Plot, SubPlot, TreeFieldNum, IdTree, ScientificName, VernName, Family, Genus, Species) # character variables
CharacVar <- CharacVar[!CharacVar %in% "none"]
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c(Time, Size, PlotArea, X, Y, TreeHeight) # numeric variables
NumVar <- NumVar[!NumVar %in% "none"]
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c(LifeStatus, CommercialSp) # logical variables
LogicVar <- LogicVar[!LogicVar %in% "none"]
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
## Units changing
### Size in cm
if(Size %in% names(Data)){
if (substr(SizeUnit, 1, 2) == "mm" | substr(SizeUnit, 1, 2) == "mi")
Data[, c(Size) := .Size/10] # mm -> cm
if (substr(SizeUnit, 1, 1) == "d")
Data[, c(Size) := .Size*10] # dm -> cm
if (substr(SizeUnit, 1, 1) == "m")
Data[, c(Size) := .Size*100] # m -> cm
}
### TreeHeight in m
if(TreeHeight %in% names(Data)){
if (substr(TreeHeightUnit, 1, 2) == "mm" | substr(TreeHeightUnit, 1, 2) == "mi")
Data[, c(TreeHeight) := .TreeHeight/1000] # mm -> m
if (substr(TreeHeightUnit, 1, 1) == "m")
Data[, c(TreeHeight) := .TreeHeight/100] # cm -> m
if (substr(TreeHeightUnit, 1, 1) == "d")
Data[, c(TreeHeight) := .TreeHeight/10] # dm -> m
}
## Necessary columns creation from the existing
### IdTree (unique along Plot, SubPlot, TreeFieldNum)
# Data[,  idTree := NULL]
if(!IdTree %in% names(Data) & all(c(Plot, SubPlot, TreeFieldNum) %in% names(Data))){
uniq_key <- unique(Data[, c(Plot, SubPlot, TreeFieldNum)])
uniq_key[, IdTree := seq(1, nrow(uniq_key))]
merge(Data, uniq_key)
IdTree <- "IdTree"
}
### POM ? (if pom is a code)
### PlotArea (not a column but a value)
if(!PlotArea %in% names(Data) & is.numeric(PlotArea)){
if(length(PlotArea) == 1){ # if PlotArea is a (1) numeric value
Data[,  PlotArea := PlotArea]
PlotArea <- "PlotArea"
}
# if(length(PlotArea) > 1){ # cas à faire : c(1 val par plot)
#   Data[,  PlotArea := PlotArea, by = Plot] # grouped
#   Data[,  PlotArea := PlotArea, by = .(Plot)] # roup rows by values in specified column
#
#   Data[Plot == Plot1,  PlotArea := PlotArea1] # subset
# }
}
### Genus Species (if ScientificName exists) (detect or ask the sep?)
if(!all(c(Genus, Species) %in% names(Data)) & ScientificName %in% names(Data)){ # or c(Genus, Species) == "none"
# Ask the sep
SfcnameSep <- readline(cat(
"What is the separator (., _, , etc) between the genus and the species in '", ScientificName,"'?")) # question to the user
Data[, c("Genus", "Species") := tstrsplit(ScientificName, SfcnameSep, fixed = TRUE)]
Genus <- "Genus"
Species <- "Species"
}
### ScientificName (if Genus & Species exist)
if(!ScientificName %in% names(Data) & all(c(Genus, Species) %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(.Genus, .Species, sep = "_")]
ScientificName <- "ScientificName"
}
# Columns renaming Data[, new = old]
Data[, Plot := .Plot]
Data[, SubPlot := .Plot]
Data[, Time := .Plot]
Data[, TreeFieldNum = .TreeFieldNum]
Data[, IdTree = .IdTree]
Data[, LifeStatus = .LifeStatus]
Data[, Size = .Size]
Data[, POM = .POM]
Data[, PlotArea = .PlotArea]
Data[, Xutm = .X]
Data[, Yutm = .Y]
Data[, ScientificName = .ScientificName]
Data[, VernName = .VernName]
Data[, Family = .Family]
Data[, Genus = .Genus]
Data[, Species = .Species]
Data[, CommercialSp = .CommercialSp]
Data[, TreeHeight = .TreeHeight]
Data[, TreeHeightUnit = .TreeHeightUnit]
}, env)) # eval(substitute( END
# Columns renaming Data[, new = old]
Data <- setnames(Data, "Plot", Plot)
Data <- setnames(Data, "SubPlot", SubPlot)
SubPlot
Plot
View(Data)
# Columns renaming Data[, new = old]
Data <- setnames(Data, "Plot", Plot)
# Columns renaming Data[, new = old]
Data <- setnames(Data, Plot, "Plot")
Data <- setnames(Data, SubPlot, "SubPlot")
SubPlot
View(Data)
library(TreeData)
library(data.table)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CensusYear", "Time")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "Circ", "DBH")
Data <- setnames(Data, "MeasCode", "POM")
Data <- setnames(Data, "idTree", "IdTree")
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# setnames(Data, "old", "new")
Data[, Plot := NULL]
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CensusYear", "Time")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "Circ", "DBH")
Data <- setnames(Data, "MeasCode", "POM")
Data <- setnames(Data, "idTree", "IdTree")
# ScientificName (if Genus & Species exist)
if(!ScientificName %in% names(Data) & all(c(Genus, Species) %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c(Genus, Species) %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c("Genus", "Species") %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
View(Data)
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
View(Data)
### as.numeric
NumVar <- c("Time", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c("LifeStatus", "CommercialSp") # logical variables
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
View(Data)
library(TreeData)
library(data.table)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# setnames(Data, "old", "new")
Data[, Plot := NULL]
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "Circ", "DBH")
Data <- setnames(Data, "MeasCode", "POM")
Data <- setnames(Data, "idTree", "IdTree")
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c("Genus", "Species") %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c("Time", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c("CensusYear", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c("LifeStatus", "CommercialSp") # logical variables
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
library(TreeData)
library(data.table)
library(TreeData)
library(data.table)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# setnames(Data, "old", "new")
Data[, Plot := NULL]
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
Data <- setnames(Data, "Circ", "DBH")
Data <- setnames(Data, "MeasCode", "POM")
Data <- setnames(Data, "idTree", "IdTree")
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c("Genus", "Species") %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c("CensusYear", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c("LifeStatus", "CommercialSp") # logical variables
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
View(Data)
StandardData <- Data
usethis::use_data(StandardData, overwrite = TRUE)
usethis::use_data_raw("StandardData")
library(TreeData)
library(data.table)
data("ParacouSubset") # import data
# INPUTS
Data = ParacouSubset
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
# Data[, CircCorr := NULL]
# Data[, CorrCode := NULL]
# setnames(Data, "old", "new")
Data[, Plot := NULL]
Data <- setnames(Data, "SubPlot", "Plot")
Data <- setnames(Data, "SubSubPlot", "SubPlot")
Data <- setnames(Data, "CodeAlive", "LifeStatus")
# Data <- setnames(Data, "Circ", "DBH")
# Data <- setnames(Data, "MeasCode", "POM") # peut-être conserver l'info code et créer une autre col hauteur
Data <- setnames(Data, "idTree", "IdTree")
if (!"DBH" %in% names(Data) & "Circ" %in% names(Data)) {
Data[, DBH := Circ/pi]
}
# ScientificName (if Genus & Species exist)
if(!"ScientificName" %in% names(Data) & all(c("Genus", "Species") %in% names(Data))){ # or ScientificName == "none"
Data[, ScientificName := paste(Genus, Species, sep = "_")]
}
### as.character
CharacVar <- c("Plot", "SubPlot", "TreeFieldNum", "IdTree", "ScientificName", "VernName", "Family", "Genus", "Species") # character variables
Data[, (CharacVar) := lapply(.SD, as.character), .SDcols = CharacVar] # (CharacVar) to say that these are existing columns and not new ones to create
### as.numeric
NumVar <- c("CensusYear", "DBH", "PlotArea", "Xutm", "Yutm") # numeric variables
Data[, (NumVar) := lapply(.SD, as.character), .SDcols = NumVar] # first as c haracter when the variable is in factor, to preserve writed information
Data[, (NumVar) := lapply(.SD, as.numeric), .SDcols = NumVar] # () to say that these are existing columns and not new ones to create
### as.logical
LogicVar <- c("LifeStatus", "CommercialSp") # logical variables
Data[, (LogicVar) := lapply(.SD, as.logical), .SDcols = LogicVar] # () to say that these are existing columns and not new ones to create
StandardData <- Data
usethis::use_data(StandardData, overwrite = TRUE)
View(StandardData)
library(TreeData)
library(data.table)
#### Import data ####
data("StandardData") # import data
Data = StandardData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 2 # number of error to add for each case
#### Missing tree size ####
# Size = NA
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, DBH := NA]
# Data[modif] # to check
# Size = 0
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, DBH := 0]
# Data[modif] # to check
#### Size with bad precision (pas .0 ou .5) ####
wrong <- c(0.2, 0.3, 0.569, 0.8)
modif <- Data[, .I[sample(.N, nError)]]
Data[modif, DBH := DBH + sample(wrong,1)]
# Data[modif] # to check
#### Resurrected tree ####
Last_census <- Data[CensusYear == 2020]
Previous_census <- Data[CensusYear == 2019]
# See if a resurrected tree already exists
MortPrev <- Previous_census[LifeStatus == 0 & IdTree %in% Last_census[LifeStatus == 1, IdTree], IdTree]
# dead in 2019, alive in 2020
Previous_census[IdTree == 101410] # dead
Last_census[IdTree == 101410] # alive
#### Missing life status ####
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, LifeStatus := NA]
Data[modif] # to check
#### Duplicated TreeFieldNum in plot-subplot association ####
modif <- Data[, .I[sample(.N, 1)]] # 1 row to change
duplicatedFieldNum <- Data[!(row.names(Data)) %in% modif & # rows != modif
Plot == Data[modif, Plot] & # same plot as modif
SubPlot == Data[modif, SubPlot], # same subplot as modif
sample(TreeFieldNum,1)] # 1 TreeFieldNum to duplicate
Data[modif, TreeFieldNum := duplicatedFieldNum] # on the row to modif, we duplicate the TreeFieldNum
# Data[TreeFieldNum == duplicatedFieldNum] # to check
#### Unseen tree but alive tree after ####
#### Duplicated IdTree in a census ####
idModif <- Last_census[, sample(IdTree, nError)] # ne chercher que dans ceux qui ne sont pas à verifier pour eviter de prendre certains avec un duplicatedID # selectionner 2 IdTree à modifier
duplicatedID <- Last_census[!(IdTree %in% idModif), sample(IdTree, 1)] # IdTree != modif
Data[IdTree %in% idModif, IdTree := duplicatedID] # we duplicate the IdTree on the previous selected IdTree
Data[CensusYear == 2020 & IdTree == duplicatedID] # to check
#### Abnomal growth ####
#### Abnomal recruit ####
#### Save this test data in the package ####
TestData <- Data
usethis::use_data(TestData, overwrite = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "POM", "Xutm", "Yutm")
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(Vars[v]), "Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
# Check for missing coordinates
# missing_coor <- Data[is.na(get(X)) | is.na(get(Y))] # transformer en 1 vect
# if(any(missing_coor)){
#
#   Data[missing_coor, Comment := paste0("Missing coordinates: ",X,", ",Y)]
# }
View(Data)
View(TestData)
data("StandardData") # import data
View(StandardData)
library(TreeData)
knitr::opts_chunk$set(echo = TRUE)
library(TreeData)
library(data.table)
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
View(Data)
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "POM", "Xutm", "Yutm")
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(Vars[v]), "Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
# Check for missing coordinates
# missing_coor <- Data[is.na(get(X)) | is.na(get(Y))] # transformer en 1 vect
# if(any(missing_coor)){
#
#   Data[missing_coor, Comment := paste0("Missing coordinates: ",X,", ",Y)]
# }
View(Data)
Vars[2]
v = 7
Vars[v]
Vars[v] %in% names(Data)
is.na(Vars[v])
Data[is.na(DBH), "Comment" := paste0("Missing value in ", Vars[v])] # comments
Data[Comment] # to check
Data[,Comment] # to check
as.name("a")
Data[!is.na(Comment)] # to check
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "LifeStatus", "DBH", "POM", "Xutm", "Yutm")
v = 7
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(as.name(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
# Check for missing coordinates
# missing_coor <- Data[is.na(get(X)) | is.na(get(Y))] # transformer en 1 vect
# if(any(missing_coor)){
#
#   Data[missing_coor, Comment := paste0("Missing coordinates: ",X,", ",Y)]
# }
for (v in 1:length(Vars)) {
if(Vars[v] %in% names(Data)){ # If the column exists
Data[is.na(get(Vars[v])),
"Comment" := paste0("Missing value in ", Vars[v])] # comments
}
}
Data[!is.na(Comment)] # to check
library(TreeData)
## code to prepare `TestData` dataset goes here
#### Packages libraries ####
library(TreeData)
library(data.table)
#### Import data ####
data("StandardData") # import data
Data = StandardData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
nError <- 2 # number of error to add for each case
#### Tree size = 0 ####
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, DBH := 0]
# Data[modif] # to check
#### Missing coordinates ####
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Xutm := NA]
Data[modif, Yutm := NA]
# Data[modif] # to check
#### Other missing values ####
Vars <- c("PlotArea", "Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree", "DBH", "LifeStatus", "MeasCode", "Family", "Genus", "Species", "VernName", "ScientificName", "CommercialSp")
modifs <- c()
for (v in 1:length(Vars)) {
modif <- Data[, .I[sample(.N, nError)]] # .I = seq_len(nrow(Data)), .N = nrows in the group -> sample 2 rows number in Data
Data[modif, Vars[v] := NA]
modifs <- c(modifs, modif)
}
# Data[modifs] # to check
#### Size with bad precision (pas .0 ou .5) ####
wrong <- c(0.2, 0.3, 0.569, 0.8)
modif <- Data[, .I[sample(.N, nError)]]
Data[modif, DBH := DBH + sample(wrong,1)]
# Data[modif] # to check
#### Resurrected tree ####
Last_census <- Data[CensusYear == 2020]
Previous_census <- Data[CensusYear == 2019]
# See if a resurrected tree already exists
MortPrev <- Previous_census[LifeStatus == 0 & IdTree %in% Last_census[LifeStatus == 1, IdTree], IdTree]
# dead in 2019, alive in 2020
Previous_census[IdTree == 101410] # dead
Last_census[IdTree == 101410] # alive
#### Duplicated TreeFieldNum in plot-subplot association ####
modif <- Data[, .I[sample(.N, 1)]] # 1 row to change
duplicatedFieldNum <- Data[!(row.names(Data)) %in% modif & # rows != modif
Plot == Data[modif, Plot] & # same plot as modif
SubPlot == Data[modif, SubPlot], # same subplot as modif
sample(TreeFieldNum,1)] # 1 TreeFieldNum to duplicate
Data[modif, TreeFieldNum := duplicatedFieldNum] # on the row to modif, we duplicate the TreeFieldNum
# Data[TreeFieldNum == duplicatedFieldNum] # to check
#### Duplicated IdTree in a census ####
idModif <- Last_census[, sample(IdTree, nError)] # ne chercher que dans ceux qui ne sont pas à verifier pour eviter de prendre certains avec un duplicatedID # selectionner 2 IdTree à modifier
duplicatedID <- Last_census[!(IdTree %in% idModif), sample(IdTree, 1)] # IdTree != modif
Data[IdTree %in% idModif, IdTree := duplicatedID] # we duplicate the IdTree on the previous selected IdTree
Data[CensusYear == 2020 & IdTree == duplicatedID] # to check
#### Unseen tree but alive tree after ####
#### Abnomal growth ####
#### Abnomal recruit ####
#### Save this test data in the package ####
TestData <- Data
usethis::use_data(TestData, overwrite = TRUE)
library(TreeData)
