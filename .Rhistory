NegativeGrowthThreshold = -2,
Pioneers = NULL,
PioneersGrowthThreshold = 7.5,
WhatToCorrect = c("POM change", "punctual", "shift"),
CorrectionType = "individual",
Digits = 1L,
DBHCorForDeadTrees = FALSE,
coef = 0.9,
DetectOnly = FALSE)
DiameterCorrectionPlot(Diam_corr, OnlyCorrected = TRUE, SeveralWindows = F)
Rslt <- RecruitmentCorrection(Diam_corr,
KeepMeas = c("MaxHOM", "MaxDate"),
MinDBH = 10,
PositiveGrowthThreshold = 5,
InvariantColumns = c("Site",
"Genus_TreeDataCor",
"Species_TreeDataCor",
"Family_TreeDataCor",
"ScientificName_TreeDataCor"),
DetectOnly = FALSE)
IdCorr <- Rslt[CorrectedRecruit %in%  TRUE, IdStem]
TreesCorr <- Rslt[IdStem %in% IdCorr, .(IdStem,
Year,
Diameter,
Diameter_DataHarmonizationCor,
CorrectedRecruit)]
IdCorr <- Rslt[CorrectedRecruit %in%  TRUE, IdStem]
TreesCorr <- Rslt[IdStem %in% IdCorr, .(IdStem,
Year,
Diameter,
Diameter_TreeDataCor,
CorrectedRecruit)]
ggplot(TreesCorr) +
aes(x = Year, y = Diameter_DataHarmonizationCor) +
geom_line(linewidth = 0.5, colour = "#112446") +
geom_point(shape = "circle", size = 1.5, mapping = aes(color = CorrectedRecruit)) +
theme_minimal() +
facet_wrap(vars(IdStem), scales = "free")
ggplot(TreesCorr) +
aes(x = Year, y = Diameter_TreeDataCor) +
geom_line(linewidth = 0.5, colour = "#112446") +
geom_point(shape = "circle", size = 1.5, mapping = aes(color = CorrectedRecruit)) +
theme_minimal() +
facet_wrap(vars(IdStem), scales = "free")
ggplot(TreesCorr) +
aes(x = Year, y = Diameter_TreeDataCor) +
geom_line(linewidth = 0.5, colour = "#112446") +
geom_point(shape = "circle", size = 1.5, mapping = aes(color = CorrectedRecruit)) +
theme_minimal() +
facet_wrap(vars(IdStem), scales = "free")
library(DataHarmonization)
detach("package:TreeData", unload = TRUE)
data("TestData")
data("TestData")
detach("package:DataHarmonization", unload = TRUE)
library(TreeData)
Rslt <- GeneralErrorsDetection(TestData)
# The detected errors
unique(Rslt[Comment != "", Comment])
Rslt[Comment != "", ]
Rslt <- BotanicalCorrection(TestData, Source = "WFO", WFOData = WFO_Backbone)
Rslt <- BotanicalCorrection(TestData, Source = "TPL", WFOData = NULL)
Status_corr <- StatusCorrection(TestData,
InvariantColumns = c("Site",
"Genus_TreeDataCor",
"Species_TreeDataCor",
"Family_TreeDataCor",
"ScientificName_TreeDataCor"),
DeathConfirmation = 2,
UseSize = FALSE,
AddRowsForForgottenCensuses = TRUE,
DetectOnly = FALSE,
RemoveRBeforeAlive = TRUE,
RemoveRAfterDeath = TRUE)
LifeStatusCorrectionPlot(Status_corr, OnlyCorrected = T, SeveralWindows = T)
View(Status_corr)
Status_corr[LifeStatus!=LifeStatus_TreeDataCor]
LifeStatusCorrectionPlot(Status_corr, SeveralWindows = T)
pdf("LifeStatusCorrectionPlots.pdf", width = 25, height = 10)
LifeStatusCorrectionPlot(Status_corr, OnlyCorrected = T, SeveralWindows = F)
dev.off()
Rslt <- Status_corr
# Order IDs and times in ascending order
Rslt <- Rslt[order(IdStem, Year)]
IdStemCor <- Rslt[LifeStatus != LifeStatusCor, IdStem] #  corrected stems
Rslt <- Status_corr
# Order IDs and times in ascending order
Rslt <- Rslt[order(IdStem, Year)]
IdStemCor <- Rslt[LifeStatus != LifeStatus_TreeDataCor, IdStem] #  corrected stems
RsltCor <- Rslt[IdStem %in% IdStemCor] #  corrected stems
# pdf("StatusCorrectionPlots.pdf", width = 25, height = 10)
for(p in 1:(ceiling(length(unique(IdStemCor))/9))){
print(ggplot(Rslt) +
aes(x = Year, y = LifeStatus_TreeDataCor) +
geom_point(shape = "circle", size = 3.9, colour = "#46337E") +
geom_smooth(span = 0.75) +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free") +
ggforce::facet_wrap_paginate(vars(IdStem), scales = "free", ncol = 3, nrow = 3, page = p)
)
}
# dev.off()
for(p in 1:(ceiling(length(unique(IdStemCor))/9))){
print(ggplot(Rslt) +
aes(x = Year, y = LifeStatus_TreeDataCor) +
geom_point(shape = "circle", size = 3.9, colour = "#46337E") +
geom_smooth(span = 0.75) +
theme_minimal() +
facet_wrap(vars(IdTree), scales = "free") +
ggforce::facet_wrap_paginate(vars(IdStem), scales = "free", ncol = 3, nrow = 3, page = p)
)
}
Diam_corr <- DiameterCorrection(
Status_corr,
KeepMeas = c("MaxHOM", "MaxDate"),
DefaultHOM = 1.3,
MaxDBH = 500,
PositiveGrowthThreshold = 5,
NegativeGrowthThreshold = -2,
Pioneers = NULL,
PioneersGrowthThreshold = 7.5,
WhatToCorrect = c("POM change", "punctual", "shift"),
CorrectionType = "individual",
Digits = 1L,
DBHCorForDeadTrees = FALSE,
coef = 0.9,
DetectOnly = FALSE)
Rslt <- TaperCorrection(Status_corr, DefaultHOM = 1.3,
TaperParameter = function(DAB, HOM) 0.156 - 0.023 * log(DAB) - 0.021 * log(HOM),
TaperFormula = function(DAB, HOM, TaperParameter, DefaultHOM) DAB / (exp(- TaperParameter*(HOM - DefaultHOM))))
View(Status_corr)
Data <- Status_corr
DefaultHOM = 1.3
TaperParameter = function(DAB, HOM) 0.156 - 0.023 * log(DAB) - 0.021 * log(HOM)
TaperFormula = function(DAB, HOM, TaperParameter, DefaultHOM) DAB / (exp(- TaperParameter*(HOM - DefaultHOM)))
DetectOnly = FALSE
if (!inherits(Data, c("data.table", "data.frame")))
stop("Data must be a data.frame or data.table")
# Check if the HOM column exists
if(!"HOM" %in% names(Data)){
stop("You have chosen to make a 'taper' correction,
but you do not have the necessary 'HOM' column in your dataset")
}
# DefaultHOM
if(!inherits(DefaultHOM, "numeric"))
stop("The 'DefaultHOM' argument must be numeric")
# TaperParameter/TaperFormula (function)
if(!all(unlist(lapply(list(TaperParameter, TaperFormula),
inherits, "function"))))
stop("The 'TaperParameter' and 'TaperFormula' arguments must be functions")
# DetectOnly (logical)
if(!inherits(DetectOnly, "logical"))
stop("The 'DetectOnly' argument must be a logical")
if(any(Data[,HOM] != DefaultHOM)){ # if some measurements of the tree were made above the POM by default
Data <- GenerateComment(Data,
condition = (Data[,HOM] != DefaultHOM),
comment = paste0("HOM different from the default HOM"))
if(DetectOnly %in% FALSE){
if(!"TaperCorDBH" %in% names(Data))
Data[, TaperCorDBH := numeric(.N) ] # start without value (I can't put NA because it's a logical, so it's a 0)
# Apply taper correction  -------------------------------------------------------------------------------------------
Data[HOM == DefaultHOM, ("TaperCorDBH") := ifelse(is.na(TaperCorDBH) | TaperCorDBH == 0, Diameter, TaperCorDBH)] # At default POM, keep the measured value
Data[HOM != DefaultHOM, ("TaperCorDBH") := TaperFormula(DAB = Diameter,
HOM = HOM,
TaperParameter = TaperParameter(DAB = Diameter, HOM = HOM),
DefaultHOM = DefaultHOM)
]
# If no HOM value, we keep the original Diameter value
Data[!is.na(Diameter) & is.na(HOM), TaperCorDBH := Diameter]
# If corrected value is 0 (DBH = NA) put NA
Data[TaperCorDBH == 0 & is.na(Diameter), TaperCorDBH := NA_real_]
# Add the column with the correction method  ------------------------------------------------------------------------
Data <- GenerateComment(Data,
condition = ( Data[,HOM] != DefaultHOM & !is.na(Data[, TaperCorDBH]) ),
comment = "taper",
column = "DiameterCorrectionMeth")
Data[, HOMCor := DefaultHOM]
} # end of the correction
}
DetectOnly %in% FALSE
# Rename correction columns
setnames(Data, c("TaperCorDBH", "HOMCor"), c("TaperDBH_TreeDataCor", "HOM_TreeDataCor"))
Data$Taper
any(Data[,HOM] != DefaultHOM)
devtools::load_all(".")
library(TreeData)
library(TreeData)
library(knitr)
library(kableExtra)
library(shiny)
library(shinydashboard)
library(shinyjs)
library(shinyWidgets)
library(data.table)
library(ggplot2)
Rslt <- TaperCorrection(Status_corr, DefaultHOM = 1.3,
TaperParameter = function(DAB, HOM) 0.156 - 0.023 * log(DAB) - 0.021 * log(HOM),
TaperFormula = function(DAB, HOM, TaperParameter, DefaultHOM) DAB / (exp(- TaperParameter*(HOM - DefaultHOM))))
DiameterCorrectionPlot(Rslt, CorCol = "TaperDBH_TreeDataCor")
devtools::load_all(".")
library(TreeData)
library(TreeData)
library(knitr)
library(kableExtra)
library(shiny)
library(shinydashboard)
library(shinyjs)
library(shinyWidgets)
library(data.table)
library(ggplot2)
DiameterCorrectionPlot(Rslt, CorCol = "TaperDBH_TreeDataCor")
Rslt <- TaperCorrection(Status_corr, DefaultHOM = 1.3,
TaperParameter = function(DAB, HOM) 0.156 - 0.023 * log(DAB) - 0.021 * log(HOM),
TaperFormula = function(DAB, HOM, TaperParameter, DefaultHOM) DAB / (exp(- TaperParameter*(HOM - DefaultHOM))))
DiameterCorrectionPlot(Rslt, CorCol = "TaperDBH_TreeDataCor")
DiameterCorrectionPlot(Rslt, CorCol = "TaperDBH_TreeDataCor", OnlyCorrected = TRUE, SeveralWindows = T)
DiameterCorrectionPlot(Rslt, CorCol = "TaperDBH_TreeDataCor", OnlyCorrected = TRUE, SeveralWindows = T)
DiameterCorrectionPlot(Rslt, CorCol = "TaperDBH_TreeDataCor", OnlyCorrected = TRUE, SeveralWindows = T)
Diam_corr <- DiameterCorrection(
Status_corr,
KeepMeas = c("MaxHOM", "MaxDate"),
DefaultHOM = 1.3,
MaxDBH = 500,
PositiveGrowthThreshold = 5,
NegativeGrowthThreshold = -2,
Pioneers = NULL,
PioneersGrowthThreshold = 7.5,
WhatToCorrect = c("POM change", "punctual", "shift"),
CorrectionType = "individual",
Digits = 1L,
DBHCorForDeadTrees = FALSE,
coef = 0.9,
DetectOnly = FALSE)
Data <- Status_corr
KeepMeas = c("MaxHOM", "MaxDate")
DefaultHOM = 1.3
MaxDBH = 500
PositiveGrowthThreshold = 5
NegativeGrowthThreshold = -2
Pioneers = NULL
PioneersGrowthThreshold = 7.5
WhatToCorrect = c("POM change", "punctual", "shift")
CorrectionType = "individual"
Digits = 1L
DBHCorForDeadTrees = FALSE
coef = 0.9
DetectOnly = FALSE
DBHRange = 10
MinIndividualNbr = 5
OtherCrit = NULL
if (!inherits(Data, c("data.table", "data.frame")))
stop("Data must be a data.frame or data.table")
# IdStem or IdTree? ---------------------------------------------------------------------------------------
# If no IdStem take IdTree
if((!"IdStem" %in% names(Data) | all(is.na(Data$IdStem))) &
("IdTree" %in% names(Data) & any(!is.na(Data$IdTree))) ){ ID <- "IdTree"
}else{ ID <- "IdStem"}
if(!any(c("IdStem", "IdTree") %in% names(Data)) | (all(is.na(Data$IdStem)) &  all(is.na(Data$IdTree))) )
stop("The 'IdStem' or 'IdTree' column is missing in your dataset")
if(!"Diameter" %in% names(Data))
stop("The 'Diameter' column does't exist in the dataset")
# DefaultHOM/Min-MaxDBH/Positive-Negative-PioneersGrowthThreshold/DBHRange/MinIndividualNbr (numeric, 1 value)
if(!all(unlist(lapply(list(DefaultHOM, MaxDBH,
PositiveGrowthThreshold, NegativeGrowthThreshold, PioneersGrowthThreshold,
DBHRange, MinIndividualNbr),
length)) %in% 1) |
!all(unlist(lapply(list(PositiveGrowthThreshold, NegativeGrowthThreshold, DefaultHOM, PioneersGrowthThreshold),
inherits, c("numeric", "integer")))))
stop("The 'PositiveGrowthThreshold', 'NegativeGrowthThreshold', 'PioneersGrowthThreshold' and 'DefaultHOM' arguments
of the 'DiameterCorrection' function must be 1 numeric value each")
if(!inherits(Pioneers, "character") & !is.null(Pioneers))
stop("'Pioneers' argument must be a characters vector, or NULL")
# WhatToCorrect
if(!any(c("POM change","punctual", "shift") %in% WhatToCorrect))
stop("The 'WhatToCorrect' argument value must be among 'POM change', 'punctual' and 'shift'")
# CorrectionType
if(!any(c("linear", "quadratic", "individual", 'phylogenetic hierarchical') %in% CorrectionType))
stop("The 'CorrectionType' argument value must be among
'quadratic', 'linear', 'individual' and 'phylogenetic hierarchical'")
# Digits
if(!inherits(Digits, "integer") & Digits != as.integer(Digits))  {
warning(paste0("The 'Digits' argument must be an integer. Value entered (", Digits, ")  coerced to ", as.integer(Digits), "."))
Digits <- as.integer(Digits)
}
if(!inherits(DetectOnly, "logical"))
stop("The 'DetectOnly' argument must be a logical")
# Taper before if 'HOM' in the dataset and not 'TaperDBH_TreeDataCor'
if(any(!is.na(Data$HOM)) & !"TaperDBH_TreeDataCor" %in% names(Data)) # HOM exists?
message("You have the 'HOM' information in your dataset.
We advise you to correct your diameters also with the 'taper' correction (TaperCorrection() function)")
# If 'POM' 'POM change' correction is advised
if((all(is.na(Data$HOM)) | !"HOM" %in% names(Data)) &
any(!is.na(Data$POM)) & !any(WhatToCorrect %in% "POM change")) # POM exists?
message("You have the 'POM' information in your dataset.
We advise you to correct your diameters also from the 'POM change' ('WhatToCorrect' argument)")
# 'POM change' correction needs 'POM' or 'HOM' values
if(!any(c("POM", "HOM") %in% names(Data)) | (all(is.na(Data$POM)) &  all(is.na(Data$HOM))) )
stop("You have chosen to make a 'POM change' correction,
but you do not have the necessary 'POM' or HOM' column in your dataset or they are empty")
# In data.table
setDT(Data)
Data <- unique(Data)   # if there are duplicate rows, delete them
if("LifeStatus_TreeDataCor" %in% names(Data)){ Status <- "LifeStatus_TreeDataCor"
}else if ("LifeStatusCor" %in% names(Data)){ Status <- "LifeStatusCor"
}else if ("LifeStatus" %in% names(Data)){ Status <- "LifeStatus"
}else{stop("You have chosen DBHCorForDeadTrees = FALSE.
To apply this choice the dataset must contain the column
'LifeStatus_TreeDataCor', 'LifeStatusCor' or 'LifeStatus'")}
if(DBHCorForDeadTrees == FALSE){
DeadTrees <- Data[get(Status) == FALSE]
Data <- Data[get(Status) == TRUE | is.na(get(Status))] # AliveTrees
# nrow(Data) == nrow(AliveTrees) + nrow(DeadTrees) # to check
}
# Remove duplicated measurements per Year because different POM or Date -----------------------------------
CompleteData <- copy(Data)
Data <- UniqueMeasurement(Data, KeepMeas = KeepMeas, ID = ID)
DuplicatedRows <- CompleteData[!Data, on = .NATURAL]
if(!"Comment" %in% names(Data)) Data[, Comment := ""]
if(DetectOnly %in% FALSE){
if(!"DiameterCorrectionMeth" %in% names(Data)) Data[, DiameterCorrectionMeth := ""]
}
# If no diameter value, write a comment
Data <- GenerateComment(Data,
condition = is.na(Data[, Diameter]),
comment = "Missing value in 'Diameter'")
# Order IDs and times in ascending order ----------------------------------------------------------------------------
Data <- Data[order(get(ID), Year)]
ID
Ids <- as.vector(na.omit(unique(Data[, get(ID)]))) # Tree Ids
# Dataset with the rows without IDS ----------------------------------------------------------------------------------
DataIDNa <- Data[is.na(get(ID))]
# Dataset with the rows without Year ----------------------------------------------------------------------------------
DataYearNa <- Data[is.na(Year)]
Ids
ID
i
# Apply for all the trees -----------------------------------------------------------------------------------------------
# i = "100635"
Data <- do.call(rbind, lapply(Ids, function(i) DiameterCorrectionByTree(
DataTree = Data[get(ID) %in% i & !is.na(Year)], # per ID, all censuses
Data = Data,
DefaultHOM = DefaultHOM,
MaxDBH = MaxDBH,
PositiveGrowthThreshold = PositiveGrowthThreshold,
NegativeGrowthThreshold = NegativeGrowthThreshold,
Pioneers = Pioneers,
PioneersGrowthThreshold = PioneersGrowthThreshold,
WhatToCorrect = WhatToCorrect,
CorrectionType = CorrectionType,
DBHRange = DBHRange,
MinIndividualNbr = MinIndividualNbr,
OtherCrit =  OtherCrit,
Digits = Digits,
coef = coef,
DetectOnly = DetectOnly
)
)) # do.call apply the 'rbind' to the lapply result
i
ID
Ids
i=Ids[1]
i
DataTree = Data[get(ID) %in% i & !is.na(Year)]
!"IdStem" %in% names(DataTree) | all(is.na(DataTree$IdStem))
"IdTree" %in% names(DataTree) & any(!is.na(DataTree$IdTree))
(!"IdStem" %in% names(DataTree) | all(is.na(DataTree$IdStem))) &
("IdTree" %in% names(DataTree) & any(!is.na(DataTree$IdTree)))
ID
# IdStem or IdTree? ---------------------------------------------------------------------------------------
# If no IdStem take IdTree
if((!"IdStem" %in% names(DataTree) | all(is.na(DataTree$IdStem))) &
("IdTree" %in% names(DataTree) & any(!is.na(DataTree$IdTree))) ){ ID <- "IdTree"
}else{ ID <- "IdStem"}
ID
!any(c("IdStem", "IdTree") %in% names(DataTree)) | (all(is.na(DataTree$IdStem)) &  all(is.na(DataTree$IdTree)))
DataIDNa
ID
Ids
!any(c("IdStem", "IdTree") %in% names(DataTree)) | (all(is.na(DataTree$IdStem)) &  all(is.na(DataTree$IdTree)))
devtools::load_all(".")
library(TreeData)
# Apply for all the trees -----------------------------------------------------------------------------------------------
# i = "100635"
Data <- do.call(rbind, lapply(Ids, function(i) DiameterCorrectionByTree(
DataTree = Data[get(ID) %in% i & !is.na(Year)], # per ID, all censuses
Data = Data,
DefaultHOM = DefaultHOM,
MaxDBH = MaxDBH,
PositiveGrowthThreshold = PositiveGrowthThreshold,
NegativeGrowthThreshold = NegativeGrowthThreshold,
Pioneers = Pioneers,
PioneersGrowthThreshold = PioneersGrowthThreshold,
WhatToCorrect = WhatToCorrect,
CorrectionType = CorrectionType,
DBHRange = DBHRange,
MinIndividualNbr = MinIndividualNbr,
OtherCrit =  OtherCrit,
Digits = Digits,
coef = coef,
DetectOnly = DetectOnly
)
)) # do.call apply the 'rbind' to the lapply result
devtools::load_all(".")
library(TreeData)
# Apply for all the trees -----------------------------------------------------------------------------------------------
# i = "100635"
Data <- do.call(rbind, lapply(Ids, function(i) DiameterCorrectionByTree(
DataTree = Data[get(ID) %in% i & !is.na(Year)], # per ID, all censuses
Data = Data,
DefaultHOM = DefaultHOM,
MaxDBH = MaxDBH,
PositiveGrowthThreshold = PositiveGrowthThreshold,
NegativeGrowthThreshold = NegativeGrowthThreshold,
Pioneers = Pioneers,
PioneersGrowthThreshold = PioneersGrowthThreshold,
WhatToCorrect = WhatToCorrect,
CorrectionType = CorrectionType,
DBHRange = DBHRange,
MinIndividualNbr = MinIndividualNbr,
OtherCrit =  OtherCrit,
Digits = Digits,
coef = coef,
DetectOnly = DetectOnly
)
)) # do.call apply the 'rbind' to the lapply result
Ids
View(Data)
i = 101605_1_auto
i = "101605_1_auto"
Data[get(ID) %in% i & !is.na(Year)]
# IDs vector --------------------------------------------------------------------------------------------------------
Ids <- as.vector(na.omit(unique(Data[!is.na(Year), get(ID)]))) # Tree Ids
Ids
# IDs vector --------------------------------------------------------------------------------------------------------
Ids <- as.vector(na.omit(unique(Data[, get(ID)]))) # Tree Ids
# IDs vector --------------------------------------------------------------------------------------------------------
Ids <- as.vector(na.omit(unique(Data[!is.na(Year), get(ID)]))) # Tree Ids
devtools::load_all(".")
devtools::load_all(".")
library(TreeData)
library(TreeData)
library(TreeData)
library(knitr)
library(kableExtra)
library(shiny)
library(shinydashboard)
library(shinyjs)
library(shinyWidgets)
library(data.table)
library(ggplot2)
Diam_corr <- DiameterCorrection(
Status_corr,
KeepMeas = c("MaxHOM", "MaxDate"),
DefaultHOM = 1.3,
MaxDBH = 500,
PositiveGrowthThreshold = 5,
NegativeGrowthThreshold = -2,
Pioneers = NULL,
PioneersGrowthThreshold = 7.5,
WhatToCorrect = c("POM change", "punctual", "shift"),
CorrectionType = "individual",
Digits = 1L,
DBHCorForDeadTrees = FALSE,
coef = 0.9,
DetectOnly = FALSE)
pdf("DiameterCorrectionPlots_TestData2.pdf", width = 25, height = 10)
DiameterCorrectionPlot(Diam_corr, OnlyCorrected = TRUE, SeveralWindows = F)
dev.off()
Rslt <- RecruitmentCorrection(Diam_corr,
KeepMeas = c("MaxHOM", "MaxDate"),
MinDBH = 10,
PositiveGrowthThreshold = 5,
InvariantColumns = c("Site",
"Genus_TreeDataCor",
"Species_TreeDataCor",
"Family_TreeDataCor",
"ScientificName_TreeDataCor"),
DetectOnly = FALSE)
devtools::load_all(".")
library(TreeData)
Rslt <- RecruitmentCorrection(Diam_corr,
KeepMeas = c("MaxHOM", "MaxDate"),
MinDBH = 10,
PositiveGrowthThreshold = 5,
InvariantColumns = c("Site",
"Genus_TreeDataCor",
"Species_TreeDataCor",
"Family_TreeDataCor",
"ScientificName_TreeDataCor"),
DetectOnly = FALSE)
IdCorr <- Rslt[CorrectedRecruit %in%  TRUE, IdStem]
TreesCorr <- Rslt[IdStem %in% IdCorr, .(IdStem,
Year,
Diameter,
Diameter_TreeDataCor,
CorrectedRecruit)]
ggplot(TreesCorr) +
aes(x = Year, y = Diameter_TreeDataCor) +
geom_line(linewidth = 0.5, colour = "#112446") +
geom_point(shape = "circle", size = 1.5, mapping = aes(color = CorrectedRecruit)) +
theme_minimal() +
facet_wrap(vars(IdStem), scales = "free")
library(TreeData)
library(knitr)
library(kableExtra)
library(shiny)
library(shinydashboard)
library(shinyjs)
library(shinyWidgets)
library(data.table)
library(ggplot2)
?StatusCorrection
