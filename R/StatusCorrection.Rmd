---
title: "StatusCorrection"
author: "Vincyane Badouard"
date: "16/02/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Inspiration: ForestData::correct_alive() and .correct_alive_tree()

Return: Create the 'LifeStatusCor' column

- if usesize : if DBH != NA -> Alive
- [*Dead* > Alive] -> NA
- add rows for the forgotten censuses between 2 'Alive'
- [Alive > *Dead*/*NA* > Alive] -> Alive
- [Alive > *NA* > Dead] -> NA
- [Alive > *Dead* > NA] -> Dead

- [Alive > *NA* > *NA*]:
if deathconfirmation > nrow(LifeStatus = "NA") -> NA
if deathconfirmation =< nrow(LifeStatus = "NA") -> Dead


# Packages libraries
```{r, include = FALSE}
library(TreeData)
library(data.table)
```


# Import data & other inputs
```{r}
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary

# Args
Censuses = c(2011:2021) # censuses for the plot in which the tree is (numeric)
deathconfirmation = 2 # (numeric)
usesize = FALSE # (logical)
```

# Ask to the user
```{r}
# The LifeStatus coding
# here
# 1 = alive (TRUE)
# 0 = dead (FALSE)
# NA = unseen
```

# Function per tree (IdTree)
## Data creation
```{r}
# Wanted seq: Dead > Alive > NA > Dead > Alive > NA > NA > Dead > NA

DataTree <- Data[IdTree == "100658"]

AddR <- DataTree[2:5] # the rows to copy
AddR[, CensusYear := c(2012:2015)] # the rows to add

DataTree <- rbindlist(list(DataTree, AddR)) # add rows

DataTree <- DataTree[order(CensusYear)]

DataTree[, LifeStatus := c(FALSE, TRUE, NA, FALSE, TRUE, NA, NA, FALSE, NA)] # write the sequence

```

## Code
```{r}
# Arrange year in ascending order
DataTree <- DataTree[order(CensusYear)] # order de dt


if(!length(unique(DataTree$Plot)) == 1){ # if there are several plots for the same idtree
  stop(paste0("tree ",unique(DataTree$IdTree)," has multiple plots: " ,paste0(unique(DataTree$Plot), collapse = "/")))
}
```

### Use the size presence as a witness of the living status of the tree
```{r}
if(usesize){
  DataTree[!is.na(DBH), LifeStatusCor := TRUE] # c'est tout ? une taille = vivant ? 
  
}else{
  DataTree[, LifeStatusCor := LifeStatus] # we will work on a new col and keep the original col intact
}
```

### Work
```{r}
# The first tree life status in the dataset
FirstStatus <- DataTree[CensusYear == min(CensusYear), LifeStatus]

# The first and last Alive record
FirstAlive <- min(DataTree[LifeStatus %in% TRUE, CensusYear])
LastAlive <- max(DataTree[LifeStatus %in% TRUE, CensusYear])

# The last time where the tree has been recorded dead (in case there are several)
LastDeathRecord <- max(DataTree[LifeStatus %in% FALSE, CensusYear])


Before
# After the last death record
After <- which(DataTree$CensusYear > LastDeathRecord) # rows id
Between
# Absents are the absent record years between first record and the last record of the tree
# s'il ya des vivant (TRUE) apres la dernière mort
Absents <- (Censuses > FirstAlive & !Censuses %in% DataTree$CensusYear)
# sinon 
Absents <- (Censuses > FirstAlive &
              Censuses < LastDeathRecord & # take into acount the last death as the end 
              !Censuses %in% DataTree$CensusYear) # Bon chais pas, REFLECHIR a ça (sur papier)

#if tree has not been reported dead yet, we search in all censuses
Absents <- (Censuses > FirstAlive & !Censuses %in% DataTree$CensusYear)
```

### Creating rows for absents
```{r}

```

### Fill in the invariant columns in the added rows
```{r}

```

### Alive > *Alive* > Alive
```{r}


```

### Enough occurrences of death to validate it
```{r}

```

### Not enough occurrences of death to validate it
