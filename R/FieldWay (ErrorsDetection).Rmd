---
title: "FieldWay (ErrorsDetection)"
author: "Vincyane Badouard"
date: "29/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Objective: Detect errors
- Check *duplicate rows*
- Check *missing value* in X-Yutm/PlotArea/Plot/SubPlot/CensusYear/TreeFieldNum/
IdTree/DBH/MeasCode/Family/Genus/Species/VernName
- Check *missing value* (NA/NULL/0) in the measurement variables  

- Check *duplicated TreeFieldNum* in plot-subplot association
- Check of the *unique association of the idTree with plot, subplot and TreeFieldNum*
- Check *duplicated idTree* in a census  

- Check for trees *outside the subplot*
- Check *invariant columns*: "Plot","SubPlot","TreeFieldNum","X","Y" for a unique "idTree"  

Internals:
+ *Bota*
- Typographie
- 1 same IdTree for different names

+ *Life status*
- Demande à l’utilisateur : considérer la présence d’une mesure comme le statut vivant de l’arbre (pas si l’on mesure les arbres morts)
- 1st occurrence: Dead
- années sautées entre 2 occurrences de vivant (missing trees) (add rows) (idTree absent of the last census, but alive at the previous census)
- NA/Dead entre 2 vivants (LifeStatus impossibles : Jesus-Christ trees (arbre ressuscite) ou desaparecido (arbre non vu à l'inventaire précédent))  

+ *Diameter*
- Check abnormal increase/decrease tree size  

+ *Recruitment*
- DBH > minDBH + (recrutement year - census before)*positivegrowththreshold  

-> Create a comment ("Comment" column) to inform about the error type.  

# Packages libraries
```{r, include = FALSE}
library(TreeData)
library(data.table)
```


# Import data & other inputs
```{r}
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
```


# Multiple checks

## Check duplicate rows
if there are duplicate rows, delete them 
```{r}
if(anyDuplicated(Data) != 0)
  unique(Data)

```

## Missing values
If the column exists, but have NA/NULL values
```{r}
# Check bota : Family/Genus/Species/ScientificName/VernName
# Check size : DBH, POM(?)
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree",
          "DBH", "POM", "TreeHeight", "StemHeight", "MeasCode",
          "Xutm", "Yutm", "Family", "Genus", "Species", "VernName")

for (v in 1:length(Vars)) {
  
  if(Vars[v] %in% names(Data)){ # If the column exists
    
    Data[is.na(get(Vars[v])),
         "Comment" := paste0("Missing value in ", Vars[v])] # comments
    
    Data[is.null(get(Vars[v])),
         "Comment" := paste0(Vars[v]," cannot be NULL")] # comments
  }
}

Data[!is.na(Comment)] # to check (13 comments)
```

## Measurement variables = 0
```{r}
Vars <- c("DBH", "POM", "TreeHeight", "StemHeight")

for (v in 1:length(Vars)) {
  if(Vars[v] %in% names(Data)){ # If the column exists
    
    Data[get(Vars[v]) == 0,
         "Comment" := paste0(Vars[v]," cannot be 0")] # comments
  }
}
Data[get(Vars) == 0] # to check
```


## Check duplicated TreeFieldNum in plot-subplot association
```{r}
# temp <- apured_trees # on 1 census
temp = Data

# Create "PlotSubNum" = "Plot/SubPlot/TreeFieldNum"
temp$PlotSubNum <- paste(temp$CensusYear, temp$Plot, temp$SubPlot, temp$TreeFieldNum, sep="/") 

# y = 2019
# p=1
# c= 4
duplicated_num <- num <- vector("character")
# if any duplicats in this col
if(anyDuplicated(temp$PlotSubNum) != 0) {
  # For each census
  for (y in unique(na.omit(temp$CensusYear))) {
    # For each plot
    for (p in unique(na.omit(temp$Plot))) {
      # For each SubPlot in this plot
      for (c in unique(na.omit(temp[temp$Plot==p, "SubPlot"]))) {
        
        num <- temp[temp$CensusYear==y & temp$Plot==p & temp$SubPlot==c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
        
        # if there are several TreeFieldNum per Plot-SubPlot combination
        if(anyDuplicated(num) != 0){
          duplicated_num <- unique(num[duplicated(num)])
          
          temp[TreeFieldNum == duplicated_num, # faire en sorte qu'il considère le problème par année
               Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
          
          # condition <- eval(parse(text = "temp$Plot==p & temp$SubPlot==c & temp$TreeFieldNum %in% duplicated_num"))
          
          # "NumArbre duplique dans une même parcelle et un même carre"
        }
      }
    }
  }
}

# temp[TreeFieldNum == duplicated_num,
#      Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
# temp[TreeFieldNum == duplicated_num]

```

## Check of the unique association of the idTree with Plot-SubPlot-TreeFieldNum
```{r}
# Check of the unique association of the IdTree with Plot-SubPlot-TreeFieldNum

correspondances <- unique(Data[, .(IdTree, Plot, SubPlot, TreeFieldNum)])

CorresIDs <- correspondances[, .(IdTree)] # all the possible idtree's
length(CorresIDs)


if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
  
  Data[duplicated(CorresIDs),
       Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
  
}
Data[duplicated(CorresIDs)== TRUE]
Data[!duplicated(CorresIDs$IdTree)]
```

## Check duplicated idTree in a census
```{r}
# Separate the data per census
# Data2016 <- Data[Time == 2016]

# Check duplicated idTree in a census
ids <- apured_trees$idTree[!is.na(apured_trees$idTree)] # Take care of excluding NAs

if(anyDuplicated(ids) != 0){
  # Extract the duplicated ids - Unique, just in case there is more than two measured for these ids.
  duplicated_ids <- unique(ids[duplicated(ids)])
  
  Data[apured_trees$idTree %in% duplicated_ids, Comment := paste0("Duplicated ",IdTree," in the census")]
  
}
```
## Check for trees outside the subplot
```{r}
# Check for trees outside the subplot

```

## Check invariant columns
```{r}
# "Plot","SubPlot","TreeFieldNum","X","Y"

```

# Internals

## Bota
## Life status
### Check missing trees compared to the previous census (add rows)
*Missing tree* = idTree absent of the last census, but alive at the previous census.
```{r}
# Check missing trees compared to the previous census (add rows)
LastTime <- max(Data[,get(Time)]) # Last census year
LastCens <- Data[get(Time) == LastTime]
PreviousTime <- max(unique(Data[get(Time) < LastTime, get(Time)])) # Previous census year
PreviousCens <- Data[get(Time) == PreviousTime]

# IdTree's alive at the previous census, in the plot and subplot in common between last and previous census
PreviousCensPlot <- unique(Data[,get(Plot)]) # unique(Data[,c(Plot), with = FALSE])
PreviousCensSubPlot <- 
  
  PrevIDs <- unique(PreviousCens[get(LifeStatus)== TRUE, get(IdTree)])

PrevIDs <- unique(PreviousCens$idTree[PreviousCens$CodeAlive == 1 & PreviousCens$Plot %in% plot & 
                                        PreviousCens$SubPlot %in% subplot])

unsighted <- PrevIDs[!PrevIDs %in% LastCens$idTree[!is.na(LastCens$idTree)]]

info <- c("Plot","SubPlot","TreeFieldNum","Xfield","Yfield", "idTree")

if(length(unsighted) > 0){
  unsighted_trees <- PreviousCens[PreviousCens$idTree %in% unsighted & PreviousCens$CodeAlive == TRUE, info]
  unsighted_trees[,names(LastCens)[!names(LastCens) %in% names(unsighted_trees)]] <- NA
  unsighted_trees$to_check <- TRUE
  unsighted_trees$apurement_codes <- "unseen"
  unsighted_trees$comments <- "Arbre oublie/non vu"
  LastCens <- rbind(LastCens,unsighted_trees[,names(LastCens)]) 
}
row.names(LastCens) <- NULL
```
## Diameter
## Recruitment

