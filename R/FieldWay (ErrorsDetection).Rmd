---
title: "FieldWay (ErrorsDetection)"
author: "Vincyane Badouard"
date: "29/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Objective: Detect errors
- Check *duplicate rows*
- Check *missing value* in X-Yutm/PlotArea/Plot/SubPlot/CensusYear/TreeFieldNum/
IdTree/DBH/MeasCode/Family/Genus/Species/VernName
- Check *missing value* (NA/0) in the measurement variables  

- Check *duplicated TreeFieldNum* in plot-subplot association in a census (at the site scale)
- Check of the *unique association of the idTree with plot, subplot and TreeFieldNum* (at the site scale)
- Check *duplicated idTree* in a census (at the site scale)

- Check for trees *outside the subplot*
- Check *invariant columns*: "Plot","SubPlot","TreeFieldNum","X","Y" for a unique "idTree"  

Internals:
+ *Bota*
- Special characters
- Typographie
- 1 same IdTree for different names

+ *Life status*
- Demande à l’utilisateur : considérer la présence d’une mesure comme le statut vivant de l’arbre (pas si l’on mesure les arbres morts)
- 1st occurrence: Dead
- années sautées entre 2 occurrences de vivant (missing trees) (add rows) (idTree absent of the last census, but alive at the previous census)
- NA/Dead entre 2 vivants (LifeStatus impossibles : Jesus-Christ trees (arbre ressuscite) ou desaparecido (arbre non vu à l'inventaire précédent))  

+ *Diameter*
- Check abnormal increase/decrease tree size  

+ *Recruitment*
- DBH > minDBH + (recrutement year - census before)*positivegrowththreshold  

-> Create a comment ("Comment" column) to inform about the error type.  

# Packages libraries
```{r, include = FALSE}
library(TreeData)
library(data.table)
```


# Import data & other inputs
```{r}
data("TestData") # import data
# INPUTS
Data = TestData
## data.frame to data.table
setDT(Data) # with "set" "<-" is not necessary
```


# Multiple checks

## Check duplicate rows
if there are duplicate rows, delete them 
```{r}
if(anyDuplicated(Data) != 0)
  unique(Data)

```

## Missing values
If the column exists, but have NA values
```{r}
# Check bota : Family/Genus/Species/ScientificName/VernName
# Check size : DBH, POM(?)
Vars <- c("Plot", "SubPlot", "CensusYear", "TreeFieldNum", "IdTree",
          "DBH", "POM", "TreeHeight", "StemHeight", "MeasCode",
          "Xutm", "Yutm", "Family", "Genus", "Species", "VernName")

for (v in 1:length(Vars)) {
  
  if(Vars[v] %in% names(Data)){ # If the column exists
    
    Data <- GenerateComment(Data,
                            condition = is.na(Data[,get(Vars[v])]),
                            comment = paste0("Missing value in ", Vars[v]))
  }
}

Data[Comment != ""] # to check (13 comments)
```

## Measurement variables = 0
```{r}
Vars <- c("DBH", "POM", "TreeHeight", "StemHeight")

for (v in 1:length(Vars)) {
  if(Vars[v] %in% names(Data)){ # If the column exists
    
    Data <- GenerateComment(Data,
                            condition = Data[,get(Vars[v])] == 0,
                            comment = paste0(Vars[v]," cannot be 0"))
  }
}
Data[get(Vars) == 0] # to check
```


## Check duplicated TreeFieldNum in plot-subplot association
```{r}
# Create "PlotSubNum" = "Site/CensusYear/Plot/SubPlot/TreeFieldNum"
Data[, PlotSubNum := paste(Site, CensusYear, Plot, SubPlot, TreeFieldNum, sep = "/")]

y = 2019
p=1
c= 4
duplicated_num <- num <- vector("character")

# if any duplicats in this col
if(anyDuplicated(Data$PlotSubNum) != 0) {
  # For each site
  for (s in unique(na.omit(Data$Site))) {
    # For each census
    for (y in unique(na.omit(Data$CensusYear))) {
      # For each plot
      for (p in unique(na.omit(Data$Plot))) {
        # For each SubPlot in this plot
        for (c in unique(na.omit(Data[Data$Plot==p, "SubPlot"]))) {
          
          num <- Data[Data$Site == s & Data$CensusYear == y
                      & Data$Plot == p & Data$SubPlot == c,]$TreeFieldNum # all the TreeFieldNum for each Plot-SubPlot combination
          
          # if there are several TreeFieldNum per Plot-SubPlot combination
          if(anyDuplicated(num) != 0){
            duplicated_num <- unique(num[duplicated(num)])
            
            Data[Data$Site == s & Data$CensusYear == y
                 & Data$Plot == p & Data$SubPlot == c
                 & Data$TreeFieldNum %in% duplicated_num,
                 Comment := "Duplicate TreeFieldNum in the same Plot and SubPlot"]
          }
        } # end subplot loop
      } # end plot loop
    } # end year loop
  } # end site loop
}

Data[TreeFieldNum == duplicated_num,.(Plot, SubPlot, TreeFieldNum)] # to check (1 duplicate)
```

## Check of the unique association of the idTree with Plot-SubPlot-TreeFieldNum, at the site scale
importfrom : data.table duplicated
```{r}
duplicated_ID <- CorresIDs <- vector("character")

# For each site
for (s in unique(na.omit(Data$Site))) {
  
  correspondances <- na.omit(unique(
    Data[Data$Site == s, .(IdTree, Plot, SubPlot, TreeFieldNum)] # & Data$CensusYear == y
  ))
  
  CorresIDs <- correspondances[, IdTree] # .(IdTree) all the Idtree's having a unique P-SubP-TreeFieldNum combination
  
  if(!identical(CorresIDs, unique(CorresIDs))){ # check if it's the same length, same ids -> 1 asso/ID
    
    duplicated_ID <- unique(CorresIDs[duplicated(CorresIDs)]) # identify the Idtree(s) having several P-SubP-TreeFieldNum combinations
    
    Data[Data$Site == s & Data$IdTree %in% duplicated_ID,
         Comment := "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum"]
    
  }
} # end site loop

unique(Data[Comment == "Non-unique association of the IdTree with Plot, SubPlot and TreeFieldNum",
            .(IdTree, Plot, SubPlot, TreeFieldNum)]) # to check 
```

## Check duplicated idTree in a census
```{r}
# Separate the data per census
# Data2016 <- Data[Time == 2016]

# Check duplicated idTree in a census
ids <- apured_trees$idTree[!is.na(apured_trees$idTree)] # Take care of excluding NAs

if(anyDuplicated(ids) != 0){
  # Extract the duplicated ids - Unique, just in case there is more than two measured for these ids.
  duplicated_ids <- unique(ids[duplicated(ids)])
  
  Data[apured_trees$idTree %in% duplicated_ids, Comment := paste0("Duplicated ",IdTree," in the census")]
  
}
```
## Check for trees outside the subplot
```{r}
# Check for trees outside the subplot

```

## Check invariant columns
```{r}
# "Plot","SubPlot","TreeFieldNum","X","Y"

```

# Internals

## Bota
### Special characters
### Typographie
é, è or œ
### Gapfill missing botanical names using vernacular names
based on probabilities of association of vernacular and botanical names.
The typographie must already have been corrected.
```{r}

```

## Life status
### Check missing trees compared to the previous census (add rows)
*Missing tree* = idTree absent of the last census, but alive at the previous census.
```{r}
# Check missing trees compared to the previous census (add rows)
LastTime <- max(Data[,get(Time)]) # Last census year
LastCens <- Data[get(Time) == LastTime]
PreviousTime <- max(unique(Data[get(Time) < LastTime, get(Time)])) # Previous census year
PreviousCens <- Data[get(Time) == PreviousTime]

# IdTree's alive at the previous census, in the plot and subplot in common between last and previous census
PreviousCensPlot <- unique(Data[,get(Plot)]) # unique(Data[,c(Plot), with = FALSE])
PreviousCensSubPlot <- 
  
  PrevIDs <- unique(PreviousCens[get(LifeStatus)== TRUE, get(IdTree)])

PrevIDs <- unique(PreviousCens$idTree[PreviousCens$CodeAlive == 1 & PreviousCens$Plot %in% plot & 
                                        PreviousCens$SubPlot %in% subplot])

unsighted <- PrevIDs[!PrevIDs %in% LastCens$idTree[!is.na(LastCens$idTree)]]

info <- c("Plot","SubPlot","TreeFieldNum","Xfield","Yfield", "idTree")

if(length(unsighted) > 0){
  unsighted_trees <- PreviousCens[PreviousCens$idTree %in% unsighted & PreviousCens$CodeAlive == TRUE, info]
  unsighted_trees[,names(LastCens)[!names(LastCens) %in% names(unsighted_trees)]] <- NA
  unsighted_trees$to_check <- TRUE
  unsighted_trees$apurement_codes <- "unseen"
  unsighted_trees$comments <- "Arbre oublie/non vu"
  LastCens <- rbind(LastCens,unsighted_trees[,names(LastCens)]) 
}
row.names(LastCens) <- NULL
```
## Diameter
## Recruitment

